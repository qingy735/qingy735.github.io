---
title: Java八股-计网篇
date: 2024-05-23 18:07:29
tags:
  - 计算机网络
  - Java
categories: 八股
---

# Java八股-计网篇

## 基础篇

### OSI七层模型和TCP/IP网络模型

<img src="https://gitee.com/qingy735/blogimg/raw/master/img/weixin-mianznxjsjwllsewswztwxxssc-11ecdc9c-5a06-4429-bfc4-115793749000.jpg" alt="三分恶面渣逆袭：三种网络体系结构" style="zoom:50%;" />

#### 每一层对应协议

<img src="https://gitee.com/qingy735/blogimg/raw/master/img/weixin-mianznxjsjwllsewswztwxxssc-ad64bbac-e0d5-4286-9b77-d008e8c8d419.jpg" alt="各层网络对应的网络协议" style="zoom:50%;" />

### 输入网址到网页，发生了什么

1. 浏览器对输入的URL进行解析

2. 浏览器根据输入域名进行域名解析，获取到对应的IP地址

   浏览器首先查询自身缓存中是否有这个域名对应的IP地址，如果有直接返回；没有则查询本地缓存中是否有该域名记录，如果有则直接返回；没有则查询hosts文件，有则返回；没有则查询本地DNS服务器（由网络接入服务器商提供，比如中国移动），有则返回；没有则本地DNS服务器向根域名服务器请求，根域名服务器可以直出接下来要向谁查询并告诉本地DNS，最终本地DNS查询到域名对应的IP地址，然后返回给浏览器

3. 浏览器获取到请求的域名对应的IP后首先进行TCP连接，通过三次握手建立连接，之后发送HTTP请求，HTTP请求有请求行、请求头、空行、请求数据组成；如果使用的HTTP协议是HTTP1.1及以后将开启HTTP长连接，不需要每次发送HTTP请求都要从新建立连接；如果使用了HTTPS协议，则需要进行非对称加密来传递服务器公钥并根据一定算法生成此次连接要使用的密钥，随后使用生成的回话密钥进行对称加密。

4. 服务器接收到客户端发送的请求后对其做出相应，将对应的请求资源发送给浏览器

5. 浏览器根据接收到的响应报文渲染页面

6. 连接结束：浏览器进行四次挥手释放TCP连接

## HTTP

### HTTP状态码

<img src="https://gitee.com/qingy735/blogimg/raw/master/img/6-五大类HTTP状态码.webp" alt="6-五大类HTTP状态码" style="zoom:50%;" />

`301`表示永久移动，请求的资源已被永久移动到新位置。服务器返回此响应时，会返回新的资源地址

`302`表示临时性移动，服务器从另外的地址响应资源，但是客户端还应该使用这个地址

`304`表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制



### HTTP常见字段

- *Host*

  客户端发送请求时，用来指定服务器的域名

- *Content-Length*

  服务器返回数据时，会有该字段，表示本次响应数据的长度。**由于是基于TCP进行通信，所以存在粘包问题，HTTP协议通过设置回车符、换行符作为HTTP Header的边界，通过Content-Length字段作为Http Body的边界**

- *Connection*

  客户端要求服务器使用**HTTP 长连接机制**

  ```html
  Connection: Keep-Alive
  ```

- *Content-Type*

  服务器响应时返回给客户端，表示本次数据是什么格式

  ```html
  Content-Type: text/html; Charset=utf-8
  ```

- *Accept*

  客户端告诉服务器自己能接受哪些数据格式

  ```html
  Accept: */*
  ```

- *Content-Encoding*

  说明数据的压缩方式，表示服务器返回的数据使用了什么压缩格式

  ```html
  Content-Encoding: gzip
  ```

- *Accept-Encoding*

  客户端告诉服务器自己可以接受哪写压缩方式

  ```html
  Accept-Encoding: gzip, deflate
  ```

### GET和POST

- GET方法将请求信息放在URL中，而POST将请求信息放在请求体中；由于浏览器对URL长度有限制，所以使用GTE的请求的URL长度有限制；GET将请求信息直接暴露在URL中不安全
- 由于GET从定义上是从服务器上获取资源，所以每次请求都不会影响到服务器而且每次的结果都是相同的即是幂等的。而POST定义是新增或提交数据，会修改服务器上的资源，是不安全的，同时每次提交数据都会创建多个资源所以不是幂等的。
- GET请求能够被缓存

### HTTP缓存技术

对于一些具有重复性的HTTP请求，比如每次请求得到的数据都是一样的，就可以将数据缓存在本地。HTTP缓存有两种实现方式：**强制缓存**和**协商缓存**

#### 强制缓存

强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在浏览器。强缓存利用以下两个HTTP响应头字段实现，表示资源在客户端缓存的有效期：

- Cache-Control：相对时间
- Expires：绝对时间

如果同时包含，Cache-Control优先级高于Expires。

1. 当浏览器第一次请求服务器资源时，服务器在返回该资源时会在响应报文头部加上Cache-Control，Cache-Control中设置了过期时间
2. 浏览器再次请求访问服务器中的该资源时，会通过请求资源的时间和过期时间判断资源是否过期，如果没有则使用该缓存，否则重新请求
3. 服务器再次收到请求后，更新响应头中的Cache-Control



#### 协商缓存

当一些请求的响应码为`304`时，表示服务器告诉浏览器可以使用本地缓存资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。

使用`ETag`字段实现协商缓存：

1. 当浏览器第一次请求访问服务器资源时，服务器在返回这个资源的同时在响应头中加上ETag唯一标识（由当前请求的资源生成）
2. 当浏览器再次请求该资源时，首先检查强制缓存是否过期，没有过期则直接使用本地缓存，否则在请求头上加`If-None-Match`字段，值为`ETag`唯一标识
3. 服务器再次接收到请求后，会根据请求中的`If-None-Match`值与当前请求资源生成的唯一标识进行比较，相等则返回`304`，不相等则返回资源并在响应头上加上新的`ETag`值
4. 如果收到`304`请求响应状态码，直接本地加载资源，否则更新资源

<img src="https://gitee.com/qingy735/blogimg/raw/master/img/http缓存.webp" alt="http缓存" style="zoom:50%;" />



### HTTP报文结构

#### 请求报文

- 请求行

  请求方法、请求URL和HTTP协议版本

  ```html
  GET /index.html HTTP/1.1
  ```

- 请求头

  包含请求的附加信息，如客户端想要接收的内容类型、浏览器类型等

- 空行

  请求头部和消息正文之间有一个空行，表示请求头部结束

- 请求体

  请求的具体内容，如 POST 请求中的表单数据；GET 请求中没有消息正文

#### 响应报文

- 状态行

  HTTP协议版本、状态码、状态消息

  ```html
  HTTP/1.0 200 OK
  ```

- 响应头

  包含响应的附加信息，如服务器类型、内容类型、内容长度等

- 空行

  表示响应头部结束

- 响应体

  响应的具体内容，如 HTML 页面。不是所有的响应都有消息正文，如 204 No Content 状态码的响应

### HTTP和HTTPS

- HTTP是超文本超文本传输协议，信息是明文传输，存在安全风险问题。HTTPS解决HTTP不安全的缺陷，在TCP和HTTP网络层之间加入了SSL/TLS安全协议，使得报文能够加密传输
- HTTP连接建立简单，在TCP三次握手之后便可以进行HTTP报文传输；而HTTPS在TCP三次握手后还需要进行SSL/TLS的握手过程才可以进行加密报文传输
- HTTPS协议需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的

#### HTTP三大风险

- 窃听风险

  混合加密实现信息的机密性，解决窃听风险

- 篡改风险

  摘要算法实现完整性，根据数据生成唯一的**指纹**，该指纹用于校验数据的完整性，解决了篡改风险

- 冒充风险

  将服务器公钥放在数字证书中，解决了冒充的风险

##### 混合加密

使用非对称加密和对称加密实现混合加密。

1. 在通信建立前采用非对称加密方式交换**会话密钥**，后续使用对称加密
2. 在通信过程中全部使用非对称加密得到的会话密钥进行对称加密，对明文数据进行加密

##### 摘要算法+数字签名

为了保证传输的内容不被篡改，针对传输的内容计算出一个**指纹**，然后一起传输给对方。对方收到报文后首先对内容也计算出一个指纹，然后将其与发送方的指纹进行对比，如果相同则说明没有被篡改，不同则被篡改了。在计算机里会**用摘要算法（哈希函数）来计算出内容的哈希值**，也就是内容的「指纹」，这个**哈希值是唯一的，且无法通过哈希值推导出内容**

但是这样并不能保证内容和哈希值不会都被替换，所以使用非对称加密对内容的哈希值进行加密形成**数字签名**，将内容和数字签名一同发送给服务器，服务器对内容计算哈希值后将其与公钥解密的数字签名比较



##### 数字证书

虽然上述可以实现对内容的可靠加密，但是不能保证服务器公钥的合法性（使用伪造的公钥和私钥）。

于是存在一个CA机构，将服务器的**个人信息+公钥**等用自己的私钥打包成一个数字证书，服务器不仅会使用私钥对内容进行签名还会将数字证书发送给接收方。客户端接收到数字证书后首先使用CA的公钥对数字证书进行解密验证合法性，判断合法后客户端就获得了服务器的公钥，之后就可以进行非对称加密来传输生成会话密钥的准备数据。



#### HTTPS 建立连接

- 客户端向服务器索要并验证服务器公钥
- 双方协商生成会话密钥
- 双方采用会话密钥进行加密通信

1. 客户端向服务器发起加密通信请求（客户端支持TLS协议版本、客户端生成的随机数A、客户端支持的密码套件）

2. 服务器收到客户端请求后对客户端发起响应（确认TLS协议版本、服务器生成的随机数B、确认密码套件、服务器的数字证书）

   >  数字证书为由CA用他自己的私钥对服务器公钥进行非对称加密得到的

3. 客户端收到服务器回应后，使用浏览器或者系统中的CA公钥对服务器发送过来的数字证书进行解密确认证书的合法性和真实性。如果证书没有问题，此时客户端就获取到了服务器的公钥，随后使用它加密报文，并且向服务器发送消息（随机数C、加密通信算法改变通知，表示随后信息都将会用会话密钥加密通信、客户端握手结束通知，同时将之前内容做摘要供服务器校验）

   >  服务器和客户端都有了三个随机数，接着使用协商好的加密算法各自生成本次通信的会话密钥

4. 服务器计算出会话密钥并向客户端发送最后信息（加密算法改变通知、服务器握手结束通知，同时将之前内容做摘要供客户端校验）

##### 中间人伪造数字证书并作为中间人转发消息

<img src="https://gitee.com/qingy735/blogimg/raw/master/img/https中间人.drawio.webp" alt="https中间人.drawio" style="zoom: 50%;" />

伪造的证书会被浏览器认定是非法的，此时用户不接受该证书就不会发生安全问题，接受了则存在安全风险。

### HTTP1.0，1.1，2.0，3.0



