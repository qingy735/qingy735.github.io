<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="referrer" content="no-referrer" />
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/img/title.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/img/title.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/img/title.ico">
  <link rel="mask-icon" href="/img/title.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.31/dist/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"qingy735.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":false,"copycode":{"enable":true,"show_result":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="QingY&#39;s Code Space">
<meta property="og:url" content="https://qingy735.github.io/index.html">
<meta property="og:site_name" content="QingY&#39;s Code Space">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="QingY">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://qingy735.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>QingY's Code Space</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">QingY's Code Space</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="QingY"
      src="/img/title.ico">
  <p class="site-author-name" itemprop="name">QingY</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/qingy735" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;qingy735" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:qingy735@qq.com" title="E-Mail → mailto:qingy735@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qingy735.github.io/posts/52880.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/title.ico">
      <meta itemprop="name" content="QingY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingY's Code Space">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | QingY's Code Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/52880.html" class="post-title-link" itemprop="url">Java八股-计网篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-23 18:07:29" itemprop="dateCreated datePublished" datetime="2024-05-23T18:07:29+08:00">2024-05-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-24 15:51:32" itemprop="dateModified" datetime="2024-05-24T15:51:32+08:00">2024-05-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="java八股-计网篇"><a class="markdownIt-Anchor" href="#java八股-计网篇"></a> Java八股-计网篇</h1>
<h2 id="基础篇"><a class="markdownIt-Anchor" href="#基础篇"></a> 基础篇</h2>
<h3 id="osi七层模型和tcpip网络模型"><a class="markdownIt-Anchor" href="#osi七层模型和tcpip网络模型"></a> OSI七层模型和TCP/IP网络模型</h3>
<img src="https://gitee.com/qingy735/blogimg/raw/master/img/weixin-mianznxjsjwllsewswztwxxssc-11ecdc9c-5a06-4429-bfc4-115793749000.jpg" alt="三分恶面渣逆袭：三种网络体系结构" style="zoom:50%;" />
<h4 id="每一层对应协议"><a class="markdownIt-Anchor" href="#每一层对应协议"></a> 每一层对应协议</h4>
<img src="https://gitee.com/qingy735/blogimg/raw/master/img/weixin-mianznxjsjwllsewswztwxxssc-ad64bbac-e0d5-4286-9b77-d008e8c8d419.jpg" alt="各层网络对应的网络协议" style="zoom:50%;" />
<h3 id="输入网址到网页发生了什么"><a class="markdownIt-Anchor" href="#输入网址到网页发生了什么"></a> 输入网址到网页，发生了什么</h3>
<ol>
<li>
<p>浏览器对输入的URL进行解析</p>
</li>
<li>
<p>浏览器根据输入域名进行域名解析，获取到对应的IP地址</p>
<p>浏览器首先查询自身缓存中是否有这个域名对应的IP地址，如果有直接返回；没有则查询本地缓存中是否有该域名记录，如果有则直接返回；没有则查询hosts文件，有则返回；没有则查询本地DNS服务器（由网络接入服务器商提供，比如中国移动），有则返回；没有则本地DNS服务器向根域名服务器请求，根域名服务器可以直出接下来要向谁查询并告诉本地DNS，最终本地DNS查询到域名对应的IP地址，然后返回给浏览器</p>
</li>
<li>
<p>浏览器获取到请求的域名对应的IP后首先进行TCP连接，通过三次握手建立连接，之后发送HTTP请求，HTTP请求有请求行、请求头、空行、请求数据组成；如果使用的HTTP协议是HTTP1.1及以后将开启HTTP长连接，不需要每次发送HTTP请求都要从新建立连接；如果使用了HTTPS协议，则需要进行非对称加密来传递服务器公钥并根据一定算法生成此次连接要使用的密钥，随后使用生成的回话密钥进行对称加密。</p>
</li>
<li>
<p>服务器接收到客户端发送的请求后对其做出相应，将对应的请求资源发送给浏览器</p>
</li>
<li>
<p>浏览器根据接收到的响应报文渲染页面</p>
</li>
<li>
<p>连接结束：浏览器进行四次挥手释放TCP连接</p>
</li>
</ol>
<h2 id="http"><a class="markdownIt-Anchor" href="#http"></a> HTTP</h2>
<h3 id="http状态码"><a class="markdownIt-Anchor" href="#http状态码"></a> HTTP状态码</h3>
<img src="https://gitee.com/qingy735/blogimg/raw/master/img/6-五大类HTTP状态码.webp" alt="6-五大类HTTP状态码" style="zoom:50%;" />
<p><code>301</code>表示永久移动，请求的资源已被永久移动到新位置。服务器返回此响应时，会返回新的资源地址</p>
<p><code>302</code>表示临时性移动，服务器从另外的地址响应资源，但是客户端还应该使用这个地址</p>
<p><code>304</code>表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制</p>
<h3 id="http常见字段"><a class="markdownIt-Anchor" href="#http常见字段"></a> HTTP常见字段</h3>
<ul>
<li>
<p><em>Host</em></p>
<p>客户端发送请求时，用来指定服务器的域名</p>
</li>
<li>
<p><em>Content-Length</em></p>
<p>服务器返回数据时，会有该字段，表示本次响应数据的长度。<strong>由于是基于TCP进行通信，所以存在粘包问题，HTTP协议通过设置回车符、换行符作为HTTP Header的边界，通过Content-Length字段作为Http Body的边界</strong></p>
</li>
<li>
<p><em>Connection</em></p>
<p>客户端要求服务器使用<strong>HTTP 长连接机制</strong></p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">Connection: Keep-Alive<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>
<p><em>Content-Type</em></p>
<p>服务器响应时返回给客户端，表示本次数据是什么格式</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">Content-Type: text/html; Charset=utf-8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>
<p><em>Accept</em></p>
<p>客户端告诉服务器自己能接受哪些数据格式</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">Accept: */*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>
<p><em>Content-Encoding</em></p>
<p>说明数据的压缩方式，表示服务器返回的数据使用了什么压缩格式</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">Content-Encoding: gzip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>
<p><em>Accept-Encoding</em></p>
<p>客户端告诉服务器自己可以接受哪写压缩方式</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">Accept-Encoding: gzip, deflate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ul>
<h3 id="get和post"><a class="markdownIt-Anchor" href="#get和post"></a> GET和POST</h3>
<ul>
<li>GET方法将请求信息放在URL中，而POST将请求信息放在请求体中；由于浏览器对URL长度有限制，所以使用GTE的请求的URL长度有限制；GET将请求信息直接暴露在URL中不安全</li>
<li>由于GET从定义上是从服务器上获取资源，所以每次请求都不会影响到服务器而且每次的结果都是相同的即是幂等的。而POST定义是新增或提交数据，会修改服务器上的资源，是不安全的，同时每次提交数据都会创建多个资源所以不是幂等的。</li>
<li>GET请求能够被缓存</li>
</ul>
<h3 id="http缓存技术"><a class="markdownIt-Anchor" href="#http缓存技术"></a> HTTP缓存技术</h3>
<p>对于一些具有重复性的HTTP请求，比如每次请求得到的数据都是一样的，就可以将数据缓存在本地。HTTP缓存有两种实现方式：<strong>强制缓存</strong>和<strong>协商缓存</strong></p>
<h4 id="强制缓存"><a class="markdownIt-Anchor" href="#强制缓存"></a> 强制缓存</h4>
<p>强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在浏览器。强缓存利用以下两个HTTP响应头字段实现，表示资源在客户端缓存的有效期：</p>
<ul>
<li>Cache-Control：相对时间</li>
<li>Expires：绝对时间</li>
</ul>
<p>如果同时包含，Cache-Control优先级高于Expires。</p>
<ol>
<li>当浏览器第一次请求服务器资源时，服务器在返回该资源时会在响应报文头部加上Cache-Control，Cache-Control中设置了过期时间</li>
<li>浏览器再次请求访问服务器中的该资源时，会通过请求资源的时间和过期时间判断资源是否过期，如果没有则使用该缓存，否则重新请求</li>
<li>服务器再次收到请求后，更新响应头中的Cache-Control</li>
</ol>
<h4 id="协商缓存"><a class="markdownIt-Anchor" href="#协商缓存"></a> 协商缓存</h4>
<p>当一些请求的响应码为<code>304</code>时，表示服务器告诉浏览器可以使用本地缓存资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。</p>
<p>使用<code>ETag</code>字段实现协商缓存：</p>
<ol>
<li>当浏览器第一次请求访问服务器资源时，服务器在返回这个资源的同时在响应头中加上ETag唯一标识（由当前请求的资源生成）</li>
<li>当浏览器再次请求该资源时，首先检查强制缓存是否过期，没有过期则直接使用本地缓存，否则在请求头上加<code>If-None-Match</code>字段，值为<code>ETag</code>唯一标识</li>
<li>服务器再次接收到请求后，会根据请求中的<code>If-None-Match</code>值与当前请求资源生成的唯一标识进行比较，相等则返回<code>304</code>，不相等则返回资源并在响应头上加上新的<code>ETag</code>值</li>
<li>如果收到<code>304</code>请求响应状态码，直接本地加载资源，否则更新资源</li>
</ol>
<img src="https://gitee.com/qingy735/blogimg/raw/master/img/http缓存.webp" alt="http缓存" style="zoom:50%;" />
<h3 id="http报文结构"><a class="markdownIt-Anchor" href="#http报文结构"></a> HTTP报文结构</h3>
<h4 id="请求报文"><a class="markdownIt-Anchor" href="#请求报文"></a> 请求报文</h4>
<ul>
<li>
<p>请求行</p>
<p>请求方法、请求URL和HTTP协议版本</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">GET /index.html HTTP/1.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>
<p>请求头</p>
<p>包含请求的附加信息，如客户端想要接收的内容类型、浏览器类型等</p>
</li>
<li>
<p>空行</p>
<p>请求头部和消息正文之间有一个空行，表示请求头部结束</p>
</li>
<li>
<p>请求体</p>
<p>请求的具体内容，如 POST 请求中的表单数据；GET 请求中没有消息正文</p>
</li>
</ul>
<h4 id="响应报文"><a class="markdownIt-Anchor" href="#响应报文"></a> 响应报文</h4>
<ul>
<li>
<p>状态行</p>
<p>HTTP协议版本、状态码、状态消息</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">HTTP/1.0 200 OK<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>
<p>响应头</p>
<p>包含响应的附加信息，如服务器类型、内容类型、内容长度等</p>
</li>
<li>
<p>空行</p>
<p>表示响应头部结束</p>
</li>
<li>
<p>响应体</p>
<p>响应的具体内容，如 HTML 页面。不是所有的响应都有消息正文，如 204 No Content 状态码的响应</p>
</li>
</ul>
<h3 id="http和https"><a class="markdownIt-Anchor" href="#http和https"></a> HTTP和HTTPS</h3>
<ul>
<li>HTTP是超文本超文本传输协议，信息是明文传输，存在安全风险问题。HTTPS解决HTTP不安全的缺陷，在TCP和HTTP网络层之间加入了SSL/TLS安全协议，使得报文能够加密传输</li>
<li>HTTP连接建立简单，在TCP三次握手之后便可以进行HTTP报文传输；而HTTPS在TCP三次握手后还需要进行SSL/TLS的握手过程才可以进行加密报文传输</li>
<li>HTTPS协议需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的</li>
</ul>
<h4 id="http三大风险"><a class="markdownIt-Anchor" href="#http三大风险"></a> HTTP三大风险</h4>
<ul>
<li>
<p>窃听风险</p>
<p>混合加密实现信息的机密性，解决窃听风险</p>
</li>
<li>
<p>篡改风险</p>
<p>摘要算法实现完整性，根据数据生成唯一的<strong>指纹</strong>，该指纹用于校验数据的完整性，解决了篡改风险</p>
</li>
<li>
<p>冒充风险</p>
<p>将服务器公钥放在数字证书中，解决了冒充的风险</p>
</li>
</ul>
<h5 id="混合加密"><a class="markdownIt-Anchor" href="#混合加密"></a> 混合加密</h5>
<p>使用非对称加密和对称加密实现混合加密。</p>
<ol>
<li>在通信建立前采用非对称加密方式交换<strong>会话密钥</strong>，后续使用对称加密</li>
<li>在通信过程中全部使用非对称加密得到的会话密钥进行对称加密，对明文数据进行加密</li>
</ol>
<h5 id="摘要算法数字签名"><a class="markdownIt-Anchor" href="#摘要算法数字签名"></a> 摘要算法+数字签名</h5>
<p>为了保证传输的内容不被篡改，针对传输的内容计算出一个<strong>指纹</strong>，然后一起传输给对方。对方收到报文后首先对内容也计算出一个指纹，然后将其与发送方的指纹进行对比，如果相同则说明没有被篡改，不同则被篡改了。在计算机里会<strong>用摘要算法（哈希函数）来计算出内容的哈希值</strong>，也就是内容的「指纹」，这个<strong>哈希值是唯一的，且无法通过哈希值推导出内容</strong></p>
<p>但是这样并不能保证内容和哈希值不会都被替换，所以使用非对称加密对内容的哈希值进行加密形成<strong>数字签名</strong>，将内容和数字签名一同发送给服务器，服务器对内容计算哈希值后将其与公钥解密的数字签名比较</p>
<h5 id="数字证书"><a class="markdownIt-Anchor" href="#数字证书"></a> 数字证书</h5>
<p>虽然上述可以实现对内容的可靠加密，但是不能保证服务器公钥的合法性（使用伪造的公钥和私钥）。</p>
<p>于是存在一个CA机构，将服务器的<strong>个人信息+公钥</strong>等用自己的私钥打包成一个数字证书，服务器不仅会使用私钥对内容进行签名还会将数字证书发送给接收方。客户端接收到数字证书后首先使用CA的公钥对数字证书进行解密验证合法性，判断合法后客户端就获得了服务器的公钥，之后就可以进行非对称加密来传输生成会话密钥的准备数据。</p>
<h4 id="https-建立连接"><a class="markdownIt-Anchor" href="#https-建立连接"></a> HTTPS 建立连接</h4>
<ul>
<li>客户端向服务器索要并验证服务器公钥</li>
<li>双方协商生成会话密钥</li>
<li>双方采用会话密钥进行加密通信</li>
</ul>
<ol>
<li>
<p>客户端向服务器发起加密通信请求（客户端支持TLS协议版本、客户端生成的随机数A、客户端支持的密码套件）</p>
</li>
<li>
<p>服务器收到客户端请求后对客户端发起响应（确认TLS协议版本、服务器生成的随机数B、确认密码套件、服务器的数字证书）</p>
<blockquote>
<p>数字证书为由CA用他自己的私钥对服务器公钥进行非对称加密得到的</p>
</blockquote>
</li>
<li>
<p>客户端收到服务器回应后，使用浏览器或者系统中的CA公钥对服务器发送过来的数字证书进行解密确认证书的合法性和真实性。如果证书没有问题，此时客户端就获取到了服务器的公钥，随后使用它加密报文，并且向服务器发送消息（随机数C、加密通信算法改变通知，表示随后信息都将会用会话密钥加密通信、客户端握手结束通知，同时将之前内容做摘要供服务器校验）</p>
<blockquote>
<p>服务器和客户端都有了三个随机数，接着使用协商好的加密算法各自生成本次通信的会话密钥</p>
</blockquote>
</li>
<li>
<p>服务器计算出会话密钥并向客户端发送最后信息（加密算法改变通知、服务器握手结束通知，同时将之前内容做摘要供客户端校验）</p>
</li>
</ol>
<h5 id="中间人伪造数字证书并作为中间人转发消息"><a class="markdownIt-Anchor" href="#中间人伪造数字证书并作为中间人转发消息"></a> 中间人伪造数字证书并作为中间人转发消息</h5>
<img src="https://gitee.com/qingy735/blogimg/raw/master/img/https中间人.drawio.webp" alt="https中间人.drawio" style="zoom: 50%;" />
<p>伪造的证书会被浏览器认定是非法的，此时用户不接受该证书就不会发生安全问题，接受了则存在安全风险。</p>
<h3 id="http10112030"><a class="markdownIt-Anchor" href="#http10112030"></a> HTTP1.0，1.1，2.0，3.0</h3>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qingy735.github.io/posts/27654.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/title.ico">
      <meta itemprop="name" content="QingY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingY's Code Space">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | QingY's Code Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/27654.html" class="post-title-link" itemprop="url">Java八股-并发编程篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-22 16:47:21" itemprop="dateCreated datePublished" datetime="2024-05-22T16:47:21+08:00">2024-05-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-23 18:06:01" itemprop="dateModified" datetime="2024-05-23T18:06:01+08:00">2024-05-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="java八股-并发编程篇"><a class="markdownIt-Anchor" href="#java八股-并发编程篇"></a> Java八股-并发编程篇</h1>
<h2 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h2>
<h3 id="并行和并发区别"><a class="markdownIt-Anchor" href="#并行和并发区别"></a> 并行和并发区别</h3>
<p>并行是指多个处理器同时执行多个任务，同一时间多个任务同时进行</p>
<p>并发是指在单处理器上一个时间段内多个任务同时执行，但是某一时刻只有一个任务执行</p>
<h3 id="进程和线程"><a class="markdownIt-Anchor" href="#进程和线程"></a> 进程和线程</h3>
<ul>
<li>进程是CPU资源分配的最小单位，线程是CPU调度的最小单位</li>
<li>进程执行在线程中，一个进程可以拥有多个线程</li>
<li>进程之间的切换是耗时的，同一个进程间的线程进行切换很快</li>
<li>同一个进程内的线程共享进程中的资源</li>
<li>不同进程间的资源相互独立</li>
</ul>
<h2 id="线程创建方式"><a class="markdownIt-Anchor" href="#线程创建方式"></a> 线程创建方式</h2>
<ul>
<li>继承Thread类</li>
</ul>
<blockquote>
<p>Java不支持多继承，如果已经继承了其他类则不能使用该方法</p>
</blockquote>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ThreadExam</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"继承Thread创建线程..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">ThreadExam</span> exam <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadExam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        exam<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>实现Runnable接口</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">RunnableExam</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"实现Runnable接口创建线程..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">RunnableExam</span> exam <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RunnableExam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>exam<span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>实现Callable接口</li>
</ul>
<blockquote>
<p>可以结合FutureTask，通过get方法获取执行结果</p>
</blockquote>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">CallableExam</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token string">"实现Callable接口创建线程..."</span>"<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">CallableExam</span> exam <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CallableExam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>exam<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="为什么不直接调用线程的run方法而去执行start"><a class="markdownIt-Anchor" href="#为什么不直接调用线程的run方法而去执行start"></a> 为什么不直接调用线程的<strong>run()<strong>方法而去执行</strong>start()</strong></h3>
<p>通过调用**start()<strong>方法来告知JVM需要创建新的线程并准备好需要的资源，然后在新建线程中执行</strong>run()<strong>方法，直接调用</strong>run()**方法相当于只是调用了Thread中的一个普通方法，执行还是在主线程中。</p>
<h3 id="线程常用调度方法"><a class="markdownIt-Anchor" href="#线程常用调度方法"></a> 线程常用调度方法</h3>
<ul>
<li>
<p>wait()</p>
<p>A线程调用该方法将被阻塞挂起直到其他线程调用notify（notifyAll）或调用A线程的interrupt方法。其使用前提必须是在同步代码块中，并且当前线程拥有该对象的锁</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token generics"><span class="token punctuation">&lt;</span>condition does not hold<span class="token punctuation">></span></span><span class="token punctuation">)</span>
		obj<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// Perform action appropriate to condition</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>wait(long timeout)</p>
<p>相比于wait方法，在指定时间超时后会自动返回</p>
</li>
<li>
<p>notify()</p>
<p>A线程调用该方法将随机唤醒阻塞在当前加锁变量上的一个线程，直到当前线程放弃当前锁，唤醒的线程可以正常地争抢该锁。使用前提也必须是在同步代码块中，并且由加锁对象执行调用。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token generics"><span class="token punctuation">&lt;</span>condition does not hold<span class="token punctuation">></span></span><span class="token punctuation">)</span>
		obj<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// Perform action appropriate to condition</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>notifyAll()</p>
<p>相比于notify，该方法将唤醒所有阻塞在当前锁上的对象，使用条件相同</p>
</li>
<li>
<p>sleep(long millis)</p>
<p>暂时让出执行时间的执行权，但是获取的锁仍然保持，等到时间到了会继续获取CPU资源，然后正常运行。</p>
</li>
<li>
<p>yield()</p>
<p>Thread类的静态方法，一个线程调用yield后，表示当前线程请求让出CPU**（注意：不会释放锁，只是从运行状态转移到就绪状态）**</p>
</li>
<li>
<p>join()</p>
<p>A、B线程，B线程调用A.join()，此时B线程会进入阻塞队列，直到线程A运行结束或线程B中断。join方法会释放锁</p>
</li>
</ul>
<h3 id="线程状态"><a class="markdownIt-Anchor" href="#线程状态"></a> 线程状态</h3>
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NEW</td>
<td style="text-align:center">初始状态：线程被创建，但还没有调用 start()方法</td>
</tr>
<tr>
<td style="text-align:center">RUNNABLE</td>
<td style="text-align:center">运行状态：Java 线程将操作系统中的就绪和运行两种状态笼统的称作“运行”</td>
</tr>
<tr>
<td style="text-align:center">BLOCKED</td>
<td style="text-align:center">阻塞状态：表示线程阻塞于锁</td>
</tr>
<tr>
<td style="text-align:center">WAITING</td>
<td style="text-align:center">等待状态：表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）</td>
</tr>
<tr>
<td style="text-align:center">TIME_WAITING</td>
<td style="text-align:center">超时等待状态：该状态不同于 WAITIND，它是可以在指定的时间自行返回的</td>
</tr>
<tr>
<td style="text-align:center">TERMINATED</td>
<td style="text-align:center">终止状态：表示当前线程已经执行完毕</td>
</tr>
</tbody>
</table>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/javathread-7.png" alt="Java线程状态变化" /></p>
<h3 id="线程间通信方式"><a class="markdownIt-Anchor" href="#线程间通信方式"></a> 线程间通信方式</h3>
<ul>
<li>volatile和synchronized</li>
<li>等待/通知机制（wait、notify等）</li>
<li>管道输入/输出流</li>
<li>Thread.join()</li>
<li>ThreadLocal</li>
</ul>
<h2 id="threadlocal"><a class="markdownIt-Anchor" href="#threadlocal"></a> ThreadLocal</h2>
<h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span>
<span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> inheritableThreadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="set方法"><a class="markdownIt-Anchor" href="#set方法"></a> set方法</h4>
<p>每个线程都有一个ThreadLocalMap对象，在使用set方法时首先通过<strong>Thread.currentThread()<strong>获取当前线程，然后调用内部方法获取到当前线程的ThreadLocalMap对象，判断是否为空，为空则调用</strong>createMap</strong>方法直接创建并赋值；不为空则以当前ThreadLocal对象为key存储。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
		map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ThreadLocalMap</span> <span class="token function">getMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> t<span class="token punctuation">.</span>threadLocals<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">createMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">,</span> <span class="token class-name">T</span> firstValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	t<span class="token punctuation">.</span>threadLocals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalMap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> firstValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="get方法"><a class="markdownIt-Anchor" href="#get方法"></a> get方法</h4>
<p>同样首先获取当前线程，然后获得线程中的ThreadLocalMap对象，判断是否为空，为空直接调用<strong>setInitialValue</strong>方法（与set方法相同，仅将value修改为null）；不为空则通过当前ThreadLocal对象获取value并返回。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">ThreadLocalMap<span class="token punctuation">.</span>Entry</span> e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
            <span class="token class-name">T</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token keyword">return</span> result<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="remove方法"><a class="markdownIt-Anchor" href="#remove方法"></a> remove方法</h4>
<p>通过<strong>getMap</strong>方法获取当前线程的ThreadLocalMap对象，非空则执行ThreadLocalMap内部<strong>remove</strong>方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
     <span class="token class-name">ThreadLocalMap</span> m <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
         m<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="threadlocalmap"><a class="markdownIt-Anchor" href="#threadlocalmap"></a> ThreadLocalMap</h3>
<p>ThreadLocalMap是ThreadLocal类的静态内部类，它是一个定制的哈希表，专门用于保存每个线程中的线程局部变量。</p>
<h4 id="entry"><a class="markdownIt-Anchor" href="#entry"></a> Entry</h4>
<p>Entry继承了弱引用<strong>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</strong>，value用于存储与特定ThreadLocal对象关联的值。因为Entry的key为弱引用，所以当ThreadLocal外部的强引用被置为null，则根据可达性分析，ThreadLocal将会在下次GC中被回收，此时ThreadLocalMap就会出现key为null的Entry，如果线程不结束则key为null的value会一直存在一条强引用链，导致无法回收造成内存泄漏。<strong>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</strong></p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/ThreadLocal-01.png" alt="ThreadLocal各引用间的关系" /></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ThreadLocal</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Object</span> value<span class="token punctuation">;</span>

    <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> k<span class="token punctuation">,</span> <span class="token class-name">Object</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
        value <span class="token operator">=</span> v<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="set方法-2"><a class="markdownIt-Anchor" href="#set方法-2"></a> set方法</h4>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment">// 获取当前key的hash值</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 防止地址冲突</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
         e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
         e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 获取当前hash对应的Entry中的ThreadLocal对象</span>
        <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 为当前key则直接更新</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
		<span class="token comment">// 为空则替换掉当前槽位的key，防止空值key导致的内存泄漏</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token function">replaceStaleEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
	<span class="token comment">// 当前位置未被初始化过</span>
    tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token operator">++</span>size<span class="token punctuation">;</span>
    <span class="token comment">// 插入后再次清除一些key为null的“脏”entry,如果大于阈值就需要扩容</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> sz<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sz <span class="token operator">>=</span> threshold<span class="token punctuation">)</span>
        <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="扩容"><a class="markdownIt-Anchor" href="#扩容"></a> 扩容</h4>
<p>ThreadLocalMap默认大小为16，阈值为2/3，超过阈值则准备扩容，首先会将key为null的entry的value设置为null便于垃圾回收，然后判断当前长度是否大于阈值的3/4，如果大于则进行扩容。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">INITIAL_CAPACITY</span> <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>

<span class="token class-name">ThreadLocalMap</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> firstKey<span class="token punctuation">,</span> <span class="token class-name">Object</span> firstValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token constant">INITIAL_CAPACITY</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> firstKey<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token constant">INITIAL_CAPACITY</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>firstKey<span class="token punctuation">,</span> firstValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">setThreshold</span><span class="token punctuation">(</span><span class="token constant">INITIAL_CAPACITY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setThreshold</span><span class="token punctuation">(</span><span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    threshold <span class="token operator">=</span> len <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">expungeStaleEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 清理完key为null的Entry后长度仍大于阈值的3/4则进行扩容</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold <span class="token operator">-</span> threshold <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">)</span>
        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="remove方法-2"><a class="markdownIt-Anchor" href="#remove方法-2"></a> remove方法</h4>
<p>首先获取当前ThreadLocal对应的key，然后执行clear方法，然后向后清理脏Entry数据</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
         e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
         <span class="token comment">// 哈希碰撞</span>
         e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            e<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 从该hash值对应索引向后开始查询，因为与当前索引发生碰撞后只会向后赋值</span>
            <span class="token comment">// 清除掉当前key后向后查询已有的key是否是通过rehash得到的，判断获取到的ThreadLocal是否为null，如果是则清除，</span>
            <span class="token comment">// 不是则重新进行hash计算并赋值，直到下一个槽位为null</span>
            <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 发生哈希碰撞，线性向后查询</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token operator">?</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> threadLocalHashCode <span class="token operator">=</span> <span class="token function">nextHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 初始为0</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">AtomicInteger</span> nextHashCode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 增长步长</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">HASH_INCREMENT</span> <span class="token operator">=</span> <span class="token number">0x61c88647</span><span class="token punctuation">;</span>
<span class="token comment">// 获取下一个hash值</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> nextHashCode<span class="token punctuation">.</span><span class="token function">getAndAdd</span><span class="token punctuation">(</span><span class="token constant">HASH_INCREMENT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="java内存模型"><a class="markdownIt-Anchor" href="#java内存模型"></a> Java内存模型</h2>
<p>线程之间的共享变量存储在<code>主内存</code>（Main Memory）中，每个线程都有一个私有的<code>本地内存</code>（Local Memory），本地内存中存储了共享变量的副本，用来进行线程内部的读写操作。</p>
<ul>
<li>当一个线程更改了本地内存中共享变量的副本后，它需要将这些更改刷新到主内存中，以确保其他线程可以看到这些更改</li>
<li>当一个线程需要读取共享变量时，它可能首先从本地内存中读取。如果本地内存中的副本是过时的，线程将从主内存中重新加载共享变量的最新值到本地内存中</li>
</ul>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/jmm-f02219aa-e762-4df0-ac08-6f4cceb535c2.jpg" alt="深入浅出 Java 多线程：Java内存模型" /></p>
<h3 id="原子性-可见性-有序性"><a class="markdownIt-Anchor" href="#原子性-可见性-有序性"></a> 原子性、可见性、有序性</h3>
<blockquote>
<p>JMM通过内存屏障来实现内存的可见性以及禁止重排序</p>
</blockquote>
<p>指令重排序规则：</p>
<ul>
<li>
<p>happens-before</p>
</li>
<li>
<p>as-if-serial</p>
</li>
</ul>
<h3 id="synchronized"><a class="markdownIt-Anchor" href="#synchronized"></a> synchronized</h3>
<blockquote>
<p>synchronized可以修饰<code>普通方法</code>（相当于对当前对象加锁）、<code>静态方法</code>（相当于对当前类加锁）、<code>代码块</code>（显式的指定对谁加锁）</p>
</blockquote>
<h4 id="synchronized特性"><a class="markdownIt-Anchor" href="#synchronized特性"></a> synchronized特性</h4>
<ul>
<li>
<p>互斥</p>
</li>
<li>
<p>刷新内存（和volatile类似）</p>
</li>
<li>
<p>可重入</p>
</li>
<li>
<p>非公平锁</p>
</li>
</ul>
<h4 id="synchronized原理"><a class="markdownIt-Anchor" href="#synchronized原理"></a> synchronized原理</h4>
<p>1、synchronized修饰代码块时，JVM采用<code>monitorenter</code>、<code>monitorexit</code>两个指令来实现同步，<code>monitorenter</code>指令指向同步代码块的开始位置，<code>monitorexit</code>指令指向同步代码块的结束位置。</p>
<p>2、synchronized 修饰同步方法时，JVM 采用<code>ACC_SYNCHRONIZED</code>标记符来实现同步，这个标识指明了该方法是一个同步方法。</p>
<p>monitorenter、monitorexit 或者 ACC_SYNCHRONIZED 都是<strong>基于 Monitor 实现</strong>的。在 Java 虚拟机（HotSpot）中，Monitor 是由<strong>ObjectMonitor 实现</strong>的，可以叫做内部锁，或者 Monitor 锁。</p>
<p>ObjectMonitor：</p>
<ul>
<li>两个队列_WaitSet、_EntryList，分别用来保存wait状态和block状态线程</li>
<li>_owner，获取到Monitor对象的线程进入_owner区时，_count+1，线程调用wait方法则会释放Monitor对象，_owner 恢复为空， _count - 1。同时该等待线程进入 _WaitSet 中，等待被唤醒。同时每进入一次_count都会加一，从而实现了synchronized的可重入特性。</li>
</ul>
<h4 id="锁级别"><a class="markdownIt-Anchor" href="#锁级别"></a> 锁级别</h4>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td>
<td>适用于只有一个线程访问同步块场景。</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度。</td>
<td>如果始终得不到锁竞争的线程使用自旋会消耗 CPU。</td>
<td>追求响应时间。同步块执行速度非常快。</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗 CPU。</td>
<td>线程阻塞，响应时间缓慢。</td>
<td>追求吞吐量。同步块执行时间较长。</td>
</tr>
</tbody>
</table>
<h4 id="偏向锁"><a class="markdownIt-Anchor" href="#偏向锁"></a> 偏向锁</h4>
<p>线程第一次进入同步块时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID。当下次该线程进入这个同步块时，会去检查锁的 Mark Word 里面是不是放的自己的线程 ID。</p>
<p>如果是，表明该线程已经获得锁了，以后该线程在进入和退出同步代码块时不需要花费CAS操作来加锁和解锁</p>
<p>如果不是，就代表有另一个线程来竞争这个偏向锁。这个时候会尝试使用 CAS 来替换 Mark Word 里面的线程 ID 为新线程的 ID。</p>
<ul>
<li>成功：表示之前的线程不存在了， Mark Word 里面的线程 ID 为新线程的 ID，锁不会升级，仍然为偏向锁；</li>
<li>失败：表示之前的线程仍然存在，那么暂停之前的线程，设置偏向锁标识为 0，并设置锁标志位为 00，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁。</li>
</ul>
<h4 id="轻量级锁"><a class="markdownIt-Anchor" href="#轻量级锁"></a> 轻量级锁</h4>
<p>多个线程在不同时间段获取同一把锁，不存在锁竞争的情况，也就没有线程阻塞。针对这种情况，JVM 采用轻量级锁来避免线程的阻塞与唤醒。</p>
<h4 id="重量级锁"><a class="markdownIt-Anchor" href="#重量级锁"></a> 重量级锁</h4>
<p>重量级锁依赖于操作系统的互斥锁（mutex，用于保证任何给定时间内，只有一个线程可以执行某一段特定的代码段） 实现，而操作系统中线程间状态的转换需要相对较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗 CPU。</p>
<h4 id="锁升级过程"><a class="markdownIt-Anchor" href="#锁升级过程"></a> 锁升级过程</h4>
<ul>
<li>检查MarkWord中存放的是不是自己的ThreadId，如果是则表示当前线程处于偏向锁状态</li>
<li>如果不是自己的ThreadId，锁升级，此时通过CAS来执行切换，新的线程根据MarkWord里现有的ThreadId，通知之前线程暂停，之前线程将MarkWord中的内容置空</li>
<li>两个线程都把锁对象的 HashCode 复制到自己新建的用于存储锁的记录空间，接着开始通过 CAS 操作，把锁对象的 MarkWord 的内容修改为自己新建的记录空间的地址的方式竞争 MarkWord</li>
<li>成功执行 CAS 的获得资源，失败的则进入自旋</li>
<li>自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于轻量级锁的状态，如果自旋失败</li>
<li>进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己</li>
</ul>
<blockquote>
<p>注：一个对象在调用原生<code>hashCode</code>方法后（<code>来自Object的，未被重写过的</code>），<strong>该对象将无法进入偏向锁状态，起步就会是轻量级锁</strong>。若<code>hashCode</code>方法的调用是在对象已经处于偏向锁]状态时调用，<strong>它的偏向状态会被立即撤销，并且锁会升级为重量级锁。</strong></p>
</blockquote>
<h4 id="synchronized锁对象"><a class="markdownIt-Anchor" href="#synchronized锁对象"></a> synchronized锁对象</h4>
<blockquote>
<p>synchronized锁住的是对象，如果锁住的这个对象在多线程中相同，那么这些线程访问synchronized修饰的代码块时总是互斥的。但是如果锁住的这个对象在多线程中是不同的，那么这些线程访问synchronized修饰的代码块时不会互斥的。</p>
</blockquote>
<ul>
<li>
<p>对象锁</p>
<p>如果时同一个实例，就会按照顺序访问，如果时不同实例，就可以同时访问</p>
<ul>
<li>锁非静态变量</li>
<li>锁this对象</li>
<li>锁非静态方法</li>
</ul>
</li>
<li>
<p>类锁</p>
<p>所有实例按照顺序访问</p>
<ul>
<li>锁静态变量</li>
<li>锁类的class</li>
<li>锁静态方法</li>
</ul>
</li>
</ul>
<h3 id="volatile"><a class="markdownIt-Anchor" href="#volatile"></a> volatile</h3>
<blockquote>
<p>volatile可以保证可见性但是不保证原子性</p>
</blockquote>
<ul>
<li>当写一个<code>volatile</code>变量时，JMM会把该线程在本地内存中的变量强制刷新到主内存中</li>
<li>这个写操作会导致其他线程中的<code>volatile</code>变量缓存无效</li>
</ul>
<p><code>volatile</code>会禁止指令重排，当使用<code>volatile</code>修饰变量时，JMM会插入内存屏障来确保以下两点：</p>
<ul>
<li>写屏障（Write Barrier）：当一个 volatile 变量被写入时，写屏障确保在该屏障之前的所有变量的写入操作都提交到主内存</li>
<li>读屏障（Read Barrier）：当读取一个 volatile 变量时，读屏障确保在该屏障之后的所有读操作都从主内存中读取</li>
</ul>
<h3 id="reentrantlock"><a class="markdownIt-Anchor" href="#reentrantlock"></a> ReentrantLock</h3>
<blockquote>
<p><code>ReentrantLock</code>是可重入的独占锁，只能由一个线程可以获取该锁，其他获取该锁的线程会被阻塞。</p>
</blockquote>
<p>ReentrantLock加锁和解锁过程：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建非公平锁（默认创建的是非公平锁，传入参数true创建公平锁）</span>
<span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取锁操作</span>
lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 执行代码逻辑</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 解锁操作</span>
    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="公平锁和非公平锁"><a class="markdownIt-Anchor" href="#公平锁和非公平锁"></a> 公平锁和非公平锁</h4>
<ul>
<li>公平锁意味着在多个线程竞争锁时，获取锁的顺序与线程请求的顺序相同，即先来先服务（FIFO）。虽然能保证锁的顺序，但是需要额外维护一个有序队列</li>
<li>非公平锁不保证线程获取锁的顺序，当锁被释放时，任何请求锁的线程都有机会获取锁，而不是按照请求的顺序。</li>
</ul>
<h4 id="synchronized和reentrantlock"><a class="markdownIt-Anchor" href="#synchronized和reentrantlock"></a> synchronized和ReentrantLock</h4>
<p>synchronized是一个关键字，而Lock属于一个接口</p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/javathread-38.png" alt="三分恶面渣逆袭：synchronized和ReentrantLock的区别" /></p>
<ul>
<li>
<p>使用方式不同</p>
<p>synchronized可以直接在方法上加锁，也可以在代码块上加锁（不需要手动释放锁，锁会自动释放），而ReentrantLock必须手动声明来加锁和释放锁</p>
</li>
<li>
<p>功能特点不同</p>
<p>如果需要更细粒度的控制（如可中断的锁操作、尝试非阻塞获取锁、超时获取锁或者使用公平锁等），可以使用 Lock</p>
</li>
</ul>
<h3 id="aqs"><a class="markdownIt-Anchor" href="#aqs"></a> AQS</h3>
<blockquote>
<p>AQS，全称是 AbstractQueuedSynchronizer，中文意思是抽象队列同步器。AQS 的思想是，如果被请求的共享资源空闲，则当前线程能够成功获取资源；否则，它将进入一个等待队列，当有其他线程释放资源时，系统会挑选等待队列中的一个线程，赋予其资源。</p>
</blockquote>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/javathread-39.png" alt="三分恶面渣逆袭：AQS抽象队列同步器" /></p>
<ul>
<li>
<p>同步状态state由volatile修饰，保证多线程之间的可见性</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>
<p>同步队列时通过内部定义的Node类来实现的，每个Node包含等待状态、前后节点、线程的引用等</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 表示该结点（对应的线程）已被取消</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">CANCELLED</span> <span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 表示后继结点（对应的线程）需要被唤醒</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SIGNAL</span>    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 表示该结点（对应的线程）在等待某一条件</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">CONDITION</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token comment">// 表示有资源可用，新head结点需要继续唤醒后继结点</span>
    <span class="token comment">// （共享模式下，多线程并发释放资源，而head唤醒其后继结点后，需要把多出来的资源留给后面的结点；</span>
    <span class="token comment">// 设置新的head结点时，会继续唤醒其后继结点）</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">PROPAGATE</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span>

    <span class="token keyword">volatile</span> <span class="token class-name">Node</span> prev<span class="token punctuation">;</span>

    <span class="token keyword">volatile</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span>

    <span class="token keyword">volatile</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>两种同步方式</p>
<ul>
<li>独占模式（Exclusive）：资源是独占的，一次只能有一个线程获取，如ReentrantLock。</li>
<li>共享模式（Share）：同时可以被多个线程获取，具体的资源个数可以通过参数指定，如Semaphore、CountDownLatch</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/view" alt="preview" /></p>
<h4 id="加锁"><a class="markdownIt-Anchor" href="#加锁"></a> 加锁</h4>
<p><code>ReentrantLock.lock()</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    sync<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>sync是一个静态内部类，继承AQS，有两个实现NofairSync(非公平锁)，FailSync(公平锁)</p>
<p><code>NonfairSync.lock</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 通过cas操作来修改state状态，表示争抢锁的操作</span>
      <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置当前获得锁状态的线程</span>
    <span class="token keyword">else</span>
      <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//尝试去获取锁</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>acquire</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">EXCLUSIVE</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于是非公平锁，所以调用lock方法时，先通过cas去抢占锁，如果抢占锁成功则保存获得锁成功的当前线程，否则调用acquire来走锁竞争逻辑。通过tryAcquire尝试获取独占锁，如果成功返回true，失败返回false，如果tryAcquire失败则会通过addWaiter方法将当前线程封装成Node添加到AQS队列尾部；acquireQueued将Node作为参数，通过自旋去尝试获取锁</p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/aqs-a0689bb2-9b18-419d-9617-6d292fbd439d.jpg" alt="acquire流程" /></p>
<h4 id="释放锁"><a class="markdownIt-Anchor" href="#释放锁"></a> 释放锁</h4>
<p><code>ReentrantLock.unlock</code></p>
<p>首先释放锁然后唤醒park的线程</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="cas"><a class="markdownIt-Anchor" href="#cas"></a> CAS</h3>
<p>CAS（Compare-and-Swap）是一种乐观锁的实现方式，全称为“比较并交换”，是一种无锁的原子操作。</p>
<p>在CAS中有三个值：V（要更新的变量）、E（预期值）、N（新值），比较并交换的过程如下：判断V是否等于E，如果等于，将V的值设置为N；如果不等，说明已经有其他线程更新了V，于是当前线程放弃更新，什么也不做。</p>
<p>当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p>
<h4 id="cas三大问题"><a class="markdownIt-Anchor" href="#cas三大问题"></a> CAS三大问题</h4>
<ul>
<li>
<p>ABA问题</p>
<p>一个值原来是A，变成了B，又变回了A，这个时候CAS检查不出来。（栈顶元素判断）</p>
<p>追加版本号或时间戳</p>
</li>
<li>
<p>长时间自旋</p>
<p>CAS长时间自旋不成功会占用大量CPU资源</p>
</li>
<li>
<p>多个共享变量的原子操作</p>
<p>当对一个共享变量执行操作时，CAS 能够保证该变量的原子性。但是对于多个共享变量，CAS 就无法保证操作的原子性，这时通常有两种做法：</p>
<ol>
<li>使用<code>AtomicReference</code>类保证对象之间的原子性，把多个变量放到一个对象里面进行 CAS 操作；</li>
<li>使用锁。锁内的临界区代码可以保证只有当前线程能操作。</li>
</ol>
</li>
</ul>
<h3 id="线程死锁"><a class="markdownIt-Anchor" href="#线程死锁"></a> 线程死锁</h3>
<ul>
<li>互斥条件</li>
<li>请求并持有</li>
<li>不可剥夺条件</li>
<li>循环等待条件</li>
</ul>
<h3 id="线程同步"><a class="markdownIt-Anchor" href="#线程同步"></a> 线程同步</h3>
<ul>
<li>互斥量</li>
<li>读写锁</li>
<li>条件变量</li>
<li>自旋锁</li>
<li>信号量</li>
</ul>
<h2 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h2>
<blockquote>
<p>线程池其实是一种池化的技术实现，池化技术的核心思想就是实现资源的复用，避免资源的重复创建和销毁带来的性能开销。线程池可以管理一堆线程，让线程执行完任务之后不进行销毁，而是继续去处理其它线程已经提交的任务。</p>
</blockquote>
<h3 id="线程池参数"><a class="markdownIt-Anchor" href="#线程池参数"></a> 线程池参数</h3>
<ul>
<li>
<p><strong>corePoolSize</strong>：核心线程数</p>
<p>线程池中核心线程数量，即使这些线程处于空闲状态也不会被回收。</p>
</li>
<li>
<p><strong>maximumPoolSize</strong>：最大线程数</p>
<p>线程池允许的最大线程数量。当工作队列满了之后，线程池会创建新线程来处理任务，直到线程数达到这个最大值。</p>
</li>
<li>
<p><strong>keepAliveTime</strong>：非核心线程存活时间</p>
<p>非核心线程的空闲存活时间。如果线程池中的线程数量超过了 corePoolSize，那么这些多余的线程在空闲时间超过 keepAliveTime 时会被终止。</p>
</li>
<li>
<p><strong>unit</strong>：非核心线程存活时间单位</p>
</li>
<li>
<p><strong>workQueue</strong>：等待队列</p>
<p>用于存放待处理任务的阻塞队列。当所有核心线程都忙时，新任务会被放在这个队列里等待执行。</p>
<ul>
<li>ArrayBlockingQueue：有界的先进先出的阻塞队列，底层是数组，适合固定大小的线程池</li>
<li>LinkedBlockingQueue：底层数据结构时链表，不指定大小默认是Integer.MAX_VALUE，相当于一个无界队列</li>
<li>PriorityBlockingQueue：支持优先队列排序的无界阻塞队列。任务按照其自然顺序或通过构造器给定的Comparator来排序</li>
<li>DelayQueue：由二叉堆实现的无界优先级阻塞队列</li>
<li>SynchronousQueue：实际上它不是一个真正的队列，因为没有容量。每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都必须等待另一个线程的插入操作</li>
</ul>
</li>
<li>
<p><strong>threadFactory</strong>：创建线程使用工厂</p>
</li>
<li>
<p><strong>handler</strong>：饱和拒绝策略</p>
<p>定义了当线程池和工作队列都满了之后对新提交的任务的处理策略。</p>
<ul>
<li>AbortPolicy：默认拒绝策略。抛出异常</li>
<li>CallerRunsPolicy：不抛出异常，会让提交任务的线程自己来执行任务</li>
<li>DiscardOldestPolicy：丢弃队列中最老的一个任务（在队列中等待最久的任务）</li>
<li>DiscardPolicy：直接丢弃该任务</li>
</ul>
</li>
</ul>
<h3 id="常见线程池"><a class="markdownIt-Anchor" href="#常见线程池"></a> 常见线程池</h3>
<ul>
<li>
<p>newFixedThreadPool (固定数目线程的线程池)</p>
<p>核心线程数和最大线程数相同，阻塞队列为无界队列LinkedBlockingQueue，容易造成OOM</p>
</li>
<li>
<p>newCachedThreadPool (可缓存线程的线程池)</p>
<p>核心线程数为0，最大线程数为Integer.MAX_VALUE，可能无限创建线程导致OOM，阻塞队列为SynchronousQueue，非核心线程空闲存活时间为60秒</p>
</li>
<li>
<p>newSingleThreadExecutor (单线程的线程池)</p>
<p>核心线程数和最大线程数都为1，阻塞队列为无界队列LinkedBlockingQueue，可能导致OOM</p>
</li>
<li>
<p>newScheduledThreadPool (定时及周期执行的线程池)</p>
<p>最大线程数为Integer.MAX_VALUE，有OOM风险，阻塞队列为DelayedWorkQueue</p>
</li>
</ul>
<h3 id="动态调节参数"><a class="markdownIt-Anchor" href="#动态调节参数"></a> 动态调节参数</h3>
<ul>
<li>利用配置中心配置线程池参数，监听修改后通过对应的<strong>set方法</strong>重新配置线程池</li>
<li>自己实现线程池，监听参数变化，根据实际业务需求更改对应参数</li>
</ul>
<h2 id="并发容器"><a class="markdownIt-Anchor" href="#并发容器"></a> 并发容器</h2>
<h3 id="concurrenthashmap"><a class="markdownIt-Anchor" href="#concurrenthashmap"></a> ConcurrentHashMap</h3>
<p>在JDK7时采用分段锁机制（Segment Locking），整个Map被分为若干段，每个段都可以独立地加锁，因此不同线程可以同时操作不同的段从而实现并发访问。</p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/map-20230816155810.png" alt="初念初恋：JDK 7 ConcurrentHashMap" /></p>
<p>在 JDK 8 及以上版本中，ConcurrentHashMap 的实现进行了优化，不再使用分段锁，而是使用了一种更加精细化的锁——桶锁，以及 CAS 无锁算法。每个桶（Node 数组的每个元素）都可以独立地加锁，从而实现更高级别的并发访问。</p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/map-20230816155924.png" alt="初念初恋：JDK 8 ConcurrentHashMap" /></p>
<p>同时，对于读操作，通常不需要加锁，可以直接读取，因为 ConcurrentHashMap 内部使用了 volatile 变量来保证内存可见性。</p>
<p>对于写操作，ConcurrentHashMap 使用 CAS 操作来实现无锁的更新，这是一种乐观锁的实现，因为它假设没有冲突发生，在实际更新数据时才检查是否有其他线程在尝试修改数据，如果有，采用悲观的锁策略，如 synchronized 代码块来保证数据的一致性。</p>
<h3 id="hashtable"><a class="markdownIt-Anchor" href="#hashtable"></a> Hashtable</h3>
<p>Hashtable 在任何时刻只允许一个线程访问整个 Map，通过对整个 Map 加锁来实现线程安全。而 ConcurrentHashMap（尤其是在 JDK 8 及之后版本）通过锁分离和 CAS 操作实现更细粒度的锁定策略，允许更高的并发。</p>
<h3 id="copyonwritearraylist"><a class="markdownIt-Anchor" href="#copyonwritearraylist"></a> CopyOnWriteArrayList</h3>
<p>CopyOnWriteArrayList 是一个线程安全的 ArrayList，它遵循写时复制（Copy-On-Write）的原则，即在写操作时，会先复制一个新的数组，然后在新的数组上进行写操作，写完之后再将原数组引用指向新数组。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qingy735.github.io/posts/43973.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/title.ico">
      <meta itemprop="name" content="QingY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingY's Code Space">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | QingY's Code Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/43973.html" class="post-title-link" itemprop="url">Java八股-MySQL篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-20 18:24:37" itemprop="dateCreated datePublished" datetime="2024-05-20T18:24:37+08:00">2024-05-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-22 16:47:54" itemprop="dateModified" datetime="2024-05-22T16:47:54+08:00">2024-05-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="java八股-mysql篇"><a class="markdownIt-Anchor" href="#java八股-mysql篇"></a> Java八股-MySQL篇</h1>
<h2 id="mysql优化"><a class="markdownIt-Anchor" href="#mysql优化"></a> MySQL优化</h2>
<h3 id="如何定位慢查询"><a class="markdownIt-Anchor" href="#如何定位慢查询"></a> 如何定位慢查询</h3>
<blockquote>
<p>聚合查询、多表查询、表数据量过大查询、深度分页查询</p>
</blockquote>
<ul>
<li>开源工具
<ul>
<li>调试工具：Arthas</li>
<li>运维工具：Prometheus、Skywalking</li>
</ul>
</li>
<li>MySQL自带慢查询日志（slow_query_log、long_query_time）</li>
</ul>
<h3 id="如何分析慢查询"><a class="markdownIt-Anchor" href="#如何分析慢查询"></a> 如何分析慢查询</h3>
<p><strong>explain</strong>或者<strong>desc</strong>获取MySQL如何执行select语句的信息</p>
<ul>
<li>possible_keys：当前sql可能用到的索引</li>
<li>key：当前sql实际命中的索引</li>
<li>key_len：索引占用的大小</li>
<li>type：sql连接的类型，NULL、system、const、eq_ref、ref、range、index、all</li>
</ul>
<h3 id="什么是索引"><a class="markdownIt-Anchor" href="#什么是索引"></a> 什么是索引</h3>
<blockquote>
<p>索引是帮助MySQL高效获取数据的数据结构（有序）</p>
</blockquote>
<p>采用B+树作为数据结构存储索引</p>
<ul>
<li>阶数更多。路径更短</li>
<li>磁盘读写代价B+树更低，非叶子结点只存储指针，叶子结点存储数据</li>
<li>B+树便于扫库和区间查询，叶子结点是一个双向链表</li>
</ul>
<h3 id="聚簇索引非聚簇索引会回表查询覆盖索引"><a class="markdownIt-Anchor" href="#聚簇索引非聚簇索引会回表查询覆盖索引"></a> 聚簇索引？非聚簇索引？会回表查询？覆盖索引？</h3>
<ul>
<li>聚簇索引：数据和索引放一块，B+树的叶子结点保存整行数据，有且只有一个</li>
<li>非聚簇索引（二级索引）：数据和索引分开存储，B+树的叶子结点保存对应的主键，可以有多个</li>
<li>回表查询：通过二级索引找到对应的主键值，到聚簇索引中查找整行数据</li>
<li>覆盖索引：查询使用了索引，并且需要返回的列在该索引中已经全部能够找到</li>
</ul>
<h3 id="mysql超大分页处理"><a class="markdownIt-Anchor" href="#mysql超大分页处理"></a> MySQL超大分页处理</h3>
<blockquote>
<p>在数据量比较大时，如果进行limit分页查询，在查询时越往后分页查询效率越低</p>
</blockquote>
<p>优化思路：一般分页查询时，通过创建覆盖索引能够比较好地提升性能，可以通过覆盖索引加子查询形式优化。</p>
<p>超大分页一般都是在数据量比较大时，我们使用limit分页查询，并且需要对数据进行排序，这个时候效率就很低，我们可以采用覆盖索引+子查询来解决。</p>
<p>先分页查询数据id字段，确定了id之后又，再用子查询来过滤，只查询这个id列表中的数据就可以了，因为查询id的时候，走的覆盖索引，所以效率可以提升很多。</p>
<pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select * 
from User_table a,
	(select id from User_table order by id limit 1000000,10) b 
where a.id &#x3D; b.id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="索引创建原则"><a class="markdownIt-Anchor" href="#索引创建原则"></a> 索引创建原则</h3>
<ul>
<li><strong>针对数据量较大，且查询比较频繁的表建立索引（10w）</strong></li>
<li><strong>针对常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</strong></li>
<li>选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li>
<li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引</li>
<li><strong>尽量使用联合索引，减少单列索引，查询时联合索引很多时候可以使用覆盖索引，节省存储空间，避免回表，提高查询效率</strong></li>
<li><strong>控制索引数量，影响增删改效率</strong></li>
<li>如果索引列不能存储NULL，创建表时使用NOT NULL约束，优化器知道每列是否包含NULL值时，可以更好地确定哪个索引更有效地用于查询</li>
</ul>
<h3 id="索引失效"><a class="markdownIt-Anchor" href="#索引失效"></a> 索引失效</h3>
<blockquote>
<p>联合索引：（a，b，c）</p>
</blockquote>
<ul>
<li>
<p>违反最左前缀法则</p>
<p>a=A，c=C时会只使用a索引</p>
</li>
<li>
<p>范围查询右边的列不能使用索引</p>
<p>a=A，b&gt;B时用不到c索引</p>
</li>
<li>
<p>索引列上进行运算操作</p>
<p>类似substring(a, 0, 2)，索引失效</p>
</li>
<li>
<p>字符串不加单引号</p>
<p>查询时，没有对字符串加单引号，MySQL的查询优化器会自动进行类型转换造成索引失效</p>
</li>
<li>
<p>模糊查询</p>
<p>%like会失效，like%不会</p>
</li>
</ul>
<h3 id="sql优化"><a class="markdownIt-Anchor" href="#sql优化"></a> sql优化</h3>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20240521161345554.png" alt="image-20240521161345554" /></p>
<h2 id="事务"><a class="markdownIt-Anchor" href="#事务"></a> 事务</h2>
<h3 id="事务特性"><a class="markdownIt-Anchor" href="#事务特性"></a> 事务特性</h3>
<blockquote>
<p>ACID；原子性、一致性、隔离性、持久性</p>
</blockquote>
<h3 id="并发事务带来了哪些问题"><a class="markdownIt-Anchor" href="#并发事务带来了哪些问题"></a> 并发事务带来了哪些问题</h3>
<blockquote>
<p>脏读：一个事务读到另一个事务还没提交的数据</p>
<p>不可重复度：一个事务先后读取同一条数据，但是两次读取数据不同</p>
<p>幻读：一个事务按照条件查询数据时，没有对应的数据行，但是插入数据时又发现这行数据已经存在</p>
</blockquote>
<h4 id="隔离级别"><a class="markdownIt-Anchor" href="#隔离级别"></a> 隔离级别：</h4>
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Read uncommitted 读未提交</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">Read committed 读已提交</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">Repeatable Read 可重复度</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">Serializable 串行化</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
<h3 id="undo-log和redo-log"><a class="markdownIt-Anchor" href="#undo-log和redo-log"></a> undo log和redo log</h3>
<ul>
<li>缓冲池（buffer pool）：主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，增删改查时先操作缓冲池中的数据（没有就从磁盘上加载并缓存），以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度</li>
<li>数据页（page）：是InnoDB存储引擎磁盘管理的最小单元，每个页大小默认为16KB，页中存储的是行数据</li>
</ul>
<h4 id="redo-log"><a class="markdownIt-Anchor" href="#redo-log"></a> redo log</h4>
<p>重做日志，记录的是事务提交时数据页的物理修改，是<strong>用来实现事务的持久性</strong></p>
<p>该文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file），前者在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存在该日志文件中，用于在刷新脏页到磁盘发生错误时进行数据恢复使用。</p>
<h4 id="undo-log"><a class="markdownIt-Anchor" href="#undo-log"></a> undo log</h4>
<p>回滚日志，用于记录数据被修改前的信息，作用包含两个：<strong>提供回滚</strong>和<strong>MVCC</strong>。undo log和redo log记录物理日志不一样，它是<strong>逻辑日志</strong>。</p>
<ul>
<li>delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然</li>
<li>update一条数据时，记录一条相反的update记录</li>
</ul>
<p><strong>undo log可以实现事务的一致性和原子性</strong></p>
<h4 id="redo-log和undo-log区别"><a class="markdownIt-Anchor" href="#redo-log和undo-log区别"></a> redo log和undo log区别</h4>
<ul>
<li>redo log记录的是数据页的物理变化，服务器宕机可以用来同步数据</li>
<li>undo log记录的是逻辑日志，当事务回滚时通过逆操作恢复原来数据</li>
<li>redo log保证事务持久性，undo log保证事务原子性和一致性</li>
</ul>
<h3 id="mvcc多版本并发控制"><a class="markdownIt-Anchor" href="#mvcc多版本并发控制"></a> MVCC（多版本并发控制）</h3>
<h4 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h4>
<ul>
<li>
<p>记录中的隐藏字段</p>
<table>
<thead>
<tr>
<th style="text-align:center">隐藏字段</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DB_TRX_ID</td>
<td style="text-align:center">最近一次修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID</td>
</tr>
<tr>
<td style="text-align:center">DB_ROLL_PTR</td>
<td style="text-align:center">回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上个版本</td>
</tr>
<tr>
<td style="text-align:center">DB_ROW_ID</td>
<td style="text-align:center">隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>undo log</p>
<p>当insert时产生的undo log日志只在回滚时需要，在事务提交后可被立即删除</p>
<p>update、delete的时候产生的undo log日志不仅回滚时需要，mvcc版本访问时也需要，不会立即删除</p>
</li>
<li>
<p>undo log版本链</p>
<p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的记录</p>
</li>
<li>
<p>readview</p>
<p>ReadView（视图读）是<strong>快照读</strong>SQL执行时MVCC提取数据的依赖，记录并维护系统当前活跃的事务（未提交）id</p>
<table>
<thead>
<tr>
<th style="text-align:center">字段</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">m_ids</td>
<td style="text-align:center">当前活跃的事务ID集合</td>
</tr>
<tr>
<td style="text-align:center">min_trx_id</td>
<td style="text-align:center">最小活跃事务ID</td>
</tr>
<tr>
<td style="text-align:center">max_trx_id</td>
<td style="text-align:center">预分配事务ID，当前最大事务ID+1</td>
</tr>
<tr>
<td style="text-align:center">creator_trx_id</td>
<td style="text-align:center">ReadView创建者的事务ID</td>
</tr>
</tbody>
</table>
<p><strong>RC隔离级别下，在事务中每一次执行快照读时生成ReadView</strong></p>
<p><strong>RR隔离级别下，仅在事务第一次执行快照读时生成ReadView，后续复用该ReadView</strong></p>
</li>
</ul>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20240521174453239.png" alt="image-20240521174453239" /></p>
<h3 id="mysql主从同步"><a class="markdownIt-Anchor" href="#mysql主从同步"></a> MySQL主从同步</h3>
<blockquote>
<p>二进制日志（binlog）记录了所有的DDL（数据定义语言 create drop等）语句和DML（数据操纵语言 update insert等），但不包括数据查询（select show）语句</p>
</blockquote>
<ul>
<li>Master主库在事务提交时会把数据变更记录在二进制日志文件Binlog中</li>
<li>从库读取主库的binlog文件，写入到从库的中继日志relay log</li>
<li>从库重做中继日志中的事件，实现主从同步</li>
</ul>
<h3 id="分库分表"><a class="markdownIt-Anchor" href="#分库分表"></a> 分库分表</h3>
<h3 id="垂直分库"><a class="markdownIt-Anchor" href="#垂直分库"></a> 垂直分库</h3>
<blockquote>
<p>以表为依据，根据业务将不同表拆分到不同库中</p>
</blockquote>
<p>特点：</p>
<ul>
<li>按业务对数据分级管理、维护、监控、扩展</li>
<li>在高并发下，提高磁盘IO和数据量连接数</li>
</ul>
<h3 id="垂直分表"><a class="markdownIt-Anchor" href="#垂直分表"></a> 垂直分表</h3>
<blockquote>
<p>以字段为依据，根据字段属性将不同字段拆分到不同表中；不常用的字段单独放一张表，把text、blob等大字段拆分出来放在附表中</p>
</blockquote>
<p>特点：</p>
<ul>
<li>冷热数据分离</li>
<li>减少IO过度争抢，两表互不影响</li>
</ul>
<h3 id="水平分库"><a class="markdownIt-Anchor" href="#水平分库"></a> 水平分库</h3>
<blockquote>
<p>将一个库的数据拆分到多个库中</p>
</blockquote>
<p>路由规则：</p>
<ul>
<li>根据id取模</li>
<li>按照id范围路由（1-100w）（100w-200w</li>
</ul>
<p>特点：</p>
<ul>
<li>解决了单库大数量、高并发的性能瓶颈问题</li>
<li>提高系统稳定性和可用性</li>
</ul>
<h3 id="水平分表"><a class="markdownIt-Anchor" href="#水平分表"></a> 水平分表</h3>
<blockquote>
<p>将一个表的数据拆分到多个表中（可以在同一个库中）</p>
</blockquote>
<p>特点：</p>
<ul>
<li>优化单表数据过大产生的性能问题</li>
<li>避免IO争抢并减少锁表的几率</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qingy735.github.io/posts/45296.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/title.ico">
      <meta itemprop="name" content="QingY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingY's Code Space">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | QingY's Code Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/45296.html" class="post-title-link" itemprop="url">Java八股-Redis篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-17 20:32:11" itemprop="dateCreated datePublished" datetime="2024-05-17T20:32:11+08:00">2024-05-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-21 16:38:49" itemprop="dateModified" datetime="2024-05-21T16:38:49+08:00">2024-05-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="java八股-redis篇"><a class="markdownIt-Anchor" href="#java八股-redis篇"></a> Java八股-Redis篇</h1>
<h2 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h2>
<h3 id="缓存"><a class="markdownIt-Anchor" href="#缓存"></a> 缓存</h3>
<h4 id="缓存穿透"><a class="markdownIt-Anchor" href="#缓存穿透"></a> 缓存穿透</h4>
<blockquote>
<p>查询一个不存在的数据，mysql查询不到数据也不会直接写入缓存，每次请求都会查数据库</p>
</blockquote>
<p>解决方案：</p>
<ul>
<li>缓存空数据，查询返回的数据为空，仍然把空结果进行缓存（简单、消耗内存，存在不一致问题）</li>
<li>布隆过滤器（缓存预热时初始化）<br />
通过多个hash函数获取hash，将hash结果对应数组位置改为1</li>
</ul>
<h4 id="缓存击穿"><a class="markdownIt-Anchor" href="#缓存击穿"></a> 缓存击穿</h4>
<blockquote>
<p>当某一个key设置了过期时间，当key过期时，恰好有大量请求访问这个key，并发请求压垮数据库</p>
</blockquote>
<p>解决方案：</p>
<ul>
<li>互斥锁<br />
保证数据强一致性，性能差</li>
<li>逻辑过期<br />
热点key不设置过期时间。发现逻辑过期，获取互斥锁，重开线程进行缓存重建并更新过期时间。高可用、性能优，不保证数据绝对一致</li>
</ul>
<h4 id="缓存雪崩"><a class="markdownIt-Anchor" href="#缓存雪崩"></a> 缓存雪崩</h4>
<blockquote>
<p>同一个时间段内缓存key同时失效或者redis宕机，导致大量请求到达数据库</p>
</blockquote>
<p>解决方案：</p>
<ul>
<li>给不同的key的过期时间添加随机值（同时过期）</li>
<li>利用redis集群提高服务可用性</li>
<li>给缓存业务添加降级限流策略（保底策略；防止缓存穿透、击穿、雪崩）</li>
<li>给业务添加多级缓存</li>
</ul>
<h4 id="mysql数据如何和redis进行同步双写一致性"><a class="markdownIt-Anchor" href="#mysql数据如何和redis进行同步双写一致性"></a> mysql数据如何和redis进行同步（双写一致性）</h4>
<h5 id="保证强一致性先删除缓存还是数据库"><a class="markdownIt-Anchor" href="#保证强一致性先删除缓存还是数据库"></a> 保证强一致性，先删除缓存还是数据库</h5>
<blockquote>
<p>延迟双删（数据库主从同步时间，延时时间不好把控且延时过程中会出现脏数据）、redis读写锁</p>
</blockquote>
<ul>
<li>
<p>先删除缓存再删除数据库</p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20240517205825138.png" alt="image-20240517205825138" /></p>
</li>
<li>
<p>先删除数据库再删除缓存</p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20240517205950034.png" alt="image-20240517205950034" /></p>
</li>
</ul>
<h5 id="保证弱一致性"><a class="markdownIt-Anchor" href="#保证弱一致性"></a> 保证弱一致性</h5>
<p>异步通知，保证最终一致性（消息队列，Canal中间件）</p>
<h4 id="redis持久化"><a class="markdownIt-Anchor" href="#redis持久化"></a> redis持久化</h4>
<ul>
<li>RDB（文件小，恢复速度快，数据丢失多）</li>
</ul>
<blockquote>
<p>把内存中的所有数据都记录到磁盘中，redis故障重启后，从磁盘读取快照文件并恢复数据</p>
</blockquote>
<p>bgsave执行原理：<br />
通过<strong>fork</strong>创建子进程复制页表信息，可以访问到磁盘数据。同时采用<strong>copy-on-write</strong> 技术，对磁盘数据进行<strong>read-only</strong> 设置，主进程写操作时拷贝数据副本进行改写，同时读取时也读取副本内容。</p>
<ul>
<li>AOF（追加文件，文件大小大，恢复速度慢，数据丢失少）</li>
</ul>
<blockquote>
<p>记录每次执行命令</p>
</blockquote>
<p>结合两者使用：首先使用RDB进行数据恢复，在使用AOF的增量数据进行数据恢复</p>
<h4 id="redis数据过期策略"><a class="markdownIt-Anchor" href="#redis数据过期策略"></a> redis数据过期策略</h4>
<ul>
<li>
<p>惰性删除（CPU友好，内存占用大）<br />
设置key过期时间后不去管他，需要使用时检查是否过期，过期立马删除，否则返回</p>
</li>
<li>
<p>定期删除<br />
每隔一段时间对一些key进行检查，删除里面过期的key</p>
</li>
</ul>
<p>redis删除策略：<strong>惰性删除</strong>+<strong>定期删除</strong></p>
<h4 id="redis数据淘汰策略"><a class="markdownIt-Anchor" href="#redis数据淘汰策略"></a> redis数据淘汰策略</h4>
<blockquote>
<p>内存不够时，继续添加新的key，redis会按照某种规则将内存中的数据删掉</p>
</blockquote>
<ul>
<li>noeviction（默认策略，不淘汰，禁止写入）</li>
<li>volatile-ttl（ttl越小越先淘汰）</li>
<li>allkeys-random（随机淘汰）</li>
<li>volatile-random（对设置了ttl的的key，随机淘汰）</li>
<li>allkeys-lru（所有key LRU）</li>
<li>volatile-lru（设置了ttl的key LRU）</li>
<li>allkeys-lfu（所有key LFU）</li>
<li>volatile-lfu（设置了ttl的key LFU）</li>
</ul>
<h3 id="分布式锁"><a class="markdownIt-Anchor" href="#分布式锁"></a> 分布式锁</h3>
<blockquote>
<p>分布式环境下synchronized锁无法实现加锁功能</p>
</blockquote>
<h4 id="setnx"><a class="markdownIt-Anchor" href="#setnx"></a> setnx</h4>
<h4 id="redissonlua脚本-原子性"><a class="markdownIt-Anchor" href="#redissonlua脚本-原子性"></a> redisson（lua脚本 原子性）</h4>
<p>加锁（成功），操作redis，另起一个线程（watch dog）每隔一段时间(默认10秒)做一次过期时间的续期<br />
加锁（失败），watch dog执行while循环不断获取锁直到达到等待时间</p>
<blockquote>
<p>redisson加锁可重入，根据线程id，利用hash结构记录线程id和重入次数key-(&lt;threadId, count&gt;)；不能解决主从数据一致性问题</p>
</blockquote>
<h2 id="其他面试题"><a class="markdownIt-Anchor" href="#其他面试题"></a> 其他面试题</h2>
<h3 id="redis主从同步"><a class="markdownIt-Anchor" href="#redis主从同步"></a> redis主从同步</h3>
<h4 id="全量同步"><a class="markdownIt-Anchor" href="#全量同步"></a> 全量同步</h4>
<ul>
<li>从节点发送数据同步请求并附带replid和offset</li>
<li>主节点判断replid是否一致，不一致表示第一次同步，返回自身replid和offset至从节点；一致则直接将repl_backlog发送给从节点，从节点根据对比offset进行数据同步</li>
<li>replid不一致，从节点保存主节点回传的replid和offset，同时主节点执行bgsave生成RDB文件并发送，从节点清空本地数据加载RDB，最后执行主节点发送的repl_backlog文件中的命令</li>
</ul>
<h4 id="增量同步slave重启或后期数据变化"><a class="markdownIt-Anchor" href="#增量同步slave重启或后期数据变化"></a> 增量同步（slave重启或后期数据变化）</h4>
<blockquote>
<p>从节点发送请求，主节点判断是否第一次请求，不是则从repl_backlog中获取offset后的数据发送给从节点，从节点执行命令</p>
</blockquote>
<h3 id="哨兵模式"><a class="markdownIt-Anchor" href="#哨兵模式"></a> 哨兵模式</h3>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20240517222059017.png" alt="image-20240517222059017" /></p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20240517222128710.png" alt="image-20240517222128710" /></p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20240517222145269.png" alt="image-20240517222145269" /></p>
<h3 id="分片集群"><a class="markdownIt-Anchor" href="#分片集群"></a> 分片集群</h3>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20240517222522412.png" alt="image-20240517222522412" /></p>
<h3 id="redis单线程为什么这么快"><a class="markdownIt-Anchor" href="#redis单线程为什么这么快"></a> Redis单线程为什么这么快</h3>
<ul>
<li>Redis是纯内存操作，执行速度快</li>
<li>采用单线程，避免了不必要的上下文切换，多线程还要考虑线程安全问题</li>
<li>使用I/O多路复用模型，非阻塞IO</li>
</ul>
<p>​	Redis性能瓶颈是<strong>网络延迟</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qingy735.github.io/posts/64965.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/title.ico">
      <meta itemprop="name" content="QingY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingY's Code Space">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | QingY's Code Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/64965.html" class="post-title-link" itemprop="url">JVM七连问</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-17 17:18:39" itemprop="dateCreated datePublished" datetime="2024-05-17T17:18:39+08:00">2024-05-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-22 17:04:54" itemprop="dateModified" datetime="2024-05-22T17:04:54+08:00">2024-05-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="jvm七连问"><a class="markdownIt-Anchor" href="#jvm七连问"></a> JVM七连问</h2>
<blockquote>
<p>关于Object o = new Object()</p>
</blockquote>
<h3 id="1-请解释一下对象的创建过程半初始化"><a class="markdownIt-Anchor" href="#1-请解释一下对象的创建过程半初始化"></a> 1、请解释一下对象的创建过程（半初始化）</h3>
<blockquote>
<p>申请空间 - 初始化 - 引用</p>
</blockquote>
<p>JVM首先检查当前类是否被加载解析和初始化过，如果没有就先执行对应的类加载器；如果加载了就为新对象分配内存空间，并且将分配的内存空间初始化为零值（成员变量，数值类型是 0，布尔类型是 false，对象类型是 null），接下来设置对象头，最后JVM执行构造方法（<code>&lt;init&gt;</code> ），将成员变量赋值为预期的值。</p>
<h3 id="2-dcldouble-check-lock要不要加volatile问题指令重排"><a class="markdownIt-Anchor" href="#2-dcldouble-check-lock要不要加volatile问题指令重排"></a> 2、DCL（double check lock）要不要加volatile问题（指令重排）</h3>
<p><strong>synchronized</strong> 内部可以重排序，锁的外部可以访问到中间状态</p>
<p>必须要加 <strong>volatile</strong>(保证线程之间的可见性和禁止指令重排序（内存屏障）)</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingleObject</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">SingleObject</span> <span class="token constant">INSTANCE</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">SingleObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SingleObject</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">INSTANCE</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">SingleObject</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">INSTANCE</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>
                    <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingleObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token constant">INSTANCE</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-对象在内存中的存储布局对象与数据的存储不同"><a class="markdownIt-Anchor" href="#3-对象在内存中的存储布局对象与数据的存储不同"></a> 3、对象在内存中的存储布局（对象与数据的存储不同）</h3>
<ul>
<li>Markword（64位机器8字节 32位机器4字节）</li>
<li>类型指针（4字节）</li>
<li>实例数据（String类型4字节）</li>
<li>对齐（被8整除）</li>
</ul>
<h3 id="4-对象头具体包括什么"><a class="markdownIt-Anchor" href="#4-对象头具体包括什么"></a> 4、对象头具体包括什么</h3>
<p><strong>markword</strong> 和 <strong>class pointer</strong></p>
<h4 id="markword"><a class="markdownIt-Anchor" href="#markword"></a> markword</h4>
<ul>
<li>锁信息</li>
<li>GC信息</li>
<li>hashcode</li>
</ul>
<h3 id="5-对象怎么定位"><a class="markdownIt-Anchor" href="#5-对象怎么定位"></a> 5、对象怎么定位</h3>
<p><strong>直接</strong> 和 <strong>间接</strong></p>
<ul>
<li>
<p>直接（默认）<br />
直接指针，仅包含实例数据，实例数据中包含类型数据指针指向方法区中的T.class</p>
<p>速度快</p>
</li>
<li>
<p>间接<br />
句柄方式，包含实例数据指针和类型数据指针</p>
<p>对象在内存中移动位置，地址不用变</p>
</li>
</ul>
<h3 id="6-对象怎么分配"><a class="markdownIt-Anchor" href="#6-对象怎么分配"></a> 6、对象怎么分配</h3>
<blockquote>
<p>栈上 - 线程本地 - Eden - Old</p>
</blockquote>
<ul>
<li>尝试分配到栈上（逃逸分析、标量替换）</li>
<li>足够大直接分配到老年代</li>
<li>TLAB（给每个线程在伊甸区的一个独立空间，线程同步）</li>
<li>分配到伊甸区</li>
</ul>
<h3 id="7-object-o-new-object在内存中占多少字节"><a class="markdownIt-Anchor" href="#7-object-o-new-object在内存中占多少字节"></a> 7、Object o = new Object()在内存中占多少字节</h3>
<p><strong>16字节</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qingy735.github.io/posts/28786.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/title.ico">
      <meta itemprop="name" content="QingY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingY's Code Space">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | QingY's Code Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/28786.html" class="post-title-link" itemprop="url">24-04-18番茄小说一面</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-04-21 21:09:26 / 修改时间：21:29:51" itemprop="dateCreated datePublished" datetime="2024-04-21T21:09:26+08:00">2024-04-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>311</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="24-04-18番茄小说一面"><a class="markdownIt-Anchor" href="#24-04-18番茄小说一面"></a> 24-04-18番茄小说一面</h2>
<h3 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题：</h3>
<ul>
<li>拷打项目</li>
<li>项目中的分布式id生成器：id产生浪费、超过id段情况（超过直接返回null）、数据库交互</li>
<li>其他的id生成器（本地的那种）：UUID、雪花算法</li>
<li>数据库分库</li>
<li>主从数据库一致性怎么保证（binlog）</li>
<li>redis用过哪写数据结构（场景）string底层实现</li>
<li>mysql多表设计（关联关系、结构设计等）</li>
<li>场景题：电影售票系统（怎么设计表，表的字段）</li>
<li><strong>volatile</strong> 、<strong>synchronized</strong> 、<strong>ReentrantLock <strong>那个熟，说前两个，让讲一下</strong>volatile</strong></li>
<li>讲一下RockerMQ（原理）</li>
<li>Http和Https区别</li>
<li>https怎么加密，加密过程</li>
<li>mysql慢查询，怎么识别慢查询（<strong>explain</strong>）</li>
</ul>
<h3 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法：</h3>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20240421212628862.png" alt="image-20240421212628862" /></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qingy735.github.io/posts/29339.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/title.ico">
      <meta itemprop="name" content="QingY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingY's Code Space">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | QingY's Code Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/29339.html" class="post-title-link" itemprop="url">24-04-15美团移动面2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-04-21 20:29:52 / 修改时间：21:10:39" itemprop="dateCreated datePublished" datetime="2024-04-21T20:29:52+08:00">2024-04-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>422</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="24-04-15美团前端移动端面2"><a class="markdownIt-Anchor" href="#24-04-15美团前端移动端面2"></a> 24-04-15美团前端&amp;移动端面2</h2>
<blockquote>
<p>上次面了一次后估计是被刷了，简历又被捞起来了重新拷打！</p>
</blockquote>
<h3 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题：</h3>
<ul>
<li>
<p>线程和进程的区别</p>
</li>
<li>
<p>TCP三次握手</p>
</li>
<li>
<p>为什么要三次握手、两次不行吗</p>
</li>
<li>
<p><strong>get</strong> 和 <strong>post</strong> 请求区别</p>
</li>
<li>
<p><strong>String</strong>、<strong>StringBuilder</strong>、<strong>StringBuffer</strong>区别</p>
</li>
<li>
<p><strong>String</strong>为什么要设计成不可变的</p>
</li>
<li>
<p>Java泛型</p>
</li>
<li>
<p><strong>HashMap</strong> 实现原理</p>
</li>
<li>
<p>扩容算法</p>
</li>
<li>
<p><strong>ConCurrentHashMap</strong></p>
</li>
<li>
<p><strong>synchronized</strong> 和 <strong>volatile</strong> 区别</p>
</li>
<li>
<p><strong>synchronized</strong> 修饰哪写</p>
</li>
<li>
<p>保证线程安全有哪些方式</p>
</li>
<li>
<p><strong>notify</strong> 和 <strong>notifyAll</strong></p>
</li>
<li>
<p>使用场景（使用位置）要求</p>
</li>
<li>
<p>垃圾回收机制</p>
</li>
<li>
<p>怎么判断对象是否要被回收（可达性分析、引用计数）</p>
</li>
<li>
<p>有哪些可以被当做 <strong>GCRoots</strong></p>
<ul>
<li>
<p>JVM栈中的引用（方法参数、局部变量等）</p>
</li>
<li>
<p>本地方法栈中的JNI引用</p>
</li>
<li>
<p>类静态变量</p>
</li>
<li>
<p>运行时常量池中的常量（String、Class类型）</p>
</li>
</ul>
</li>
<li>
<p>强引用、软引用、弱引用、虚引用区别</p>
</li>
<li>
<p>说一下哪写技能会在职业领域反复使用（比较开放，技术、沟通、协作…）</p>
</li>
</ul>
<h3 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法:</h3>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20240421210237894.png" alt="image-20240421210237894" /></p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20240421210438785.png" alt="image-20240421210438785" /></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qingy735.github.io/posts/51273.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/title.ico">
      <meta itemprop="name" content="QingY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingY's Code Space">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | QingY's Code Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/51273.html" class="post-title-link" itemprop="url">24-04-10美团移动面</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-10 16:56:58" itemprop="dateCreated datePublished" datetime="2024-04-10T16:56:58+08:00">2024-04-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-21 20:30:33" itemprop="dateModified" datetime="2024-04-21T20:30:33+08:00">2024-04-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>917</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="24-04-10美团前端移动端面"><a class="markdownIt-Anchor" href="#24-04-10美团前端移动端面"></a> 24-04-10美团前端&amp;移动端面</h2>
<h3 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题：</h3>
<ul>
<li>
<p><strong>安卓四大组件（不会直接问Java了）</strong></p>
</li>
<li>
<p><strong>说一下StringBuilder和StringBuffer区别</strong></p>
<p>StringBuilder与StringBuffer功能类似，但是StringBuffer是线程安全的，方法都添加了synchronized关键字。</p>
</li>
<li>
<p><strong>为什么不直接使用String而要用StringBuilder或者StringBuffer</strong></p>
<p>String类的对象是不可变的，一旦String对象被创建，所包含的字符串内容是不可改变的。每次对String对象进行修改操作都会生成一个新的String对象，导致大量的内存开销。而StringBuffer和StringBuilder的字符串修改操作都是直接在原有字符串对象的底层数组上进行的，而不会生成新的String对象。</p>
</li>
<li>
<p><strong>String内部成员变量、.length()方法时间复杂度多少</strong></p>
<p>以JDK8为例：包含final修饰的 <strong>char数组</strong> 和 <strong>hash</strong></p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20240410185212778.png" alt="image-20240410185212778" /></p>
<p>其中 <strong>.length()</strong> 方法调用的是 <strong>value</strong> 数组的 <strong>length</strong> 属性</p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20240410185423398.png" alt="image-20240410185423398" /></p>
</li>
<li>
<p><strong>如何将String设计成动态容量的</strong></p>
<p>问的是C++中string是可变的，能不能Java的String也实现动态长度？</p>
</li>
<li>
<p><strong>Map底层数据结构？？？如何保证key唯一</strong></p>
<p>回答的HashMap，说Map类似？不懂啥意思</p>
</li>
<li>
<p><strong>Java与C++区别</strong></p>
</li>
<li>
<p><strong>JVM、垃圾回收</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/csdnliuxin123524/article/details/81303711">JVM原理最全、清晰、通俗讲解，五天40小时吐血整理_jvm原理讲解教程最全清晰通俗讲解-CSDN博客</a></p>
</li>
<li>
<p><strong>C++源文件如何到机器码？还是字节码如何到机器码</strong></p>
</li>
<li>
<p><strong>网页输入网址到显示内容发生了什么</strong></p>
<p>1、DNS解析：发送DNS请求（浏览器缓存、本地缓存、hosts文件），发送给本地DNS服务器（缓存有直接返回），没有询问根域名服务器，根据根域名的指示找到对应的DNS服务器得到IP地址</p>
<p>2、TCP连接 三次握手</p>
<p>3、发送HTTP请求给服务器</p>
<p>4、服务器处理请求并返回响应报文</p>
<p>5、浏览器解析渲染页面</p>
<p>6、结束连接 四次挥手</p>
</li>
<li>
<p><strong>不同局域网可能包含相同ip，顶端DNS如何将查询到的信息返还给请求主机</strong></p>
<p>不懂</p>
</li>
<li>
<p><strong>线程池、如何设计</strong></p>
<p>核心线程数、最大线程数、非核心线程存活时间、阻塞队列、拒绝策略、线程工厂</p>
</li>
<li>
<p>其他忘了。。。</p>
</li>
</ul>
<h3 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法：</h3>
<ul>
<li>
<p>树的最近祖先</p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/e3698b209adb05022f00c94a63c9485b.png" alt="e3698b209adb05022f00c94a63c9485b" /></p>
</li>
<li>
<p>最长合法括号序列</p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/5eb3f230d9be3dcbdd9a43ede7b36c8b.png" alt="5eb3f230d9be3dcbdd9a43ede7b36c8b" /></p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qingy735.github.io/posts/38331.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/title.ico">
      <meta itemprop="name" content="QingY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingY's Code Space">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | QingY's Code Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/38331.html" class="post-title-link" itemprop="url">《Lightweight Remote Sensing Change Detection With Progressive Feature Aggregation and Supervised Attention》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-22 14:07:37" itemprop="dateCreated datePublished" datetime="2023-02-22T14:07:37+08:00">2023-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-07 17:03:29" itemprop="dateModified" datetime="2024-04-07T17:03:29+08:00">2024-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BA%E6%96%87/" itemprop="url" rel="index"><span itemprop="name">论文</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/10034814">Lightweight Remote Sensing Change Detection With Progressive Feature Aggregation and Supervised Attention</a></p>
</blockquote>
<h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2>
<h3 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h3>
<p>尽管之前的基于CNN的方法能够取得不错的结果，但是模型的内存和计算成本太高，很难在实际中应用</p>
<h3 id="工作"><a class="markdownIt-Anchor" href="#工作"></a> 工作</h3>
<p>提出一种新颖的轻量级网络，它通过渐进式特征聚合和监督注意力，根据移动网络提取的特征识别变化</p>
<ul>
<li>设计了一个neighbor aggregation module（NAM）来融合主干网络邻近阶段的特征，用来增强时间特征的表示能力</li>
<li>提出progressive change identifying module（PCI）从双时相特征中提取时间差异信息</li>
<li>设计了supervised attention模块（SAM）来对特征重新加权，以有效地从高层到低层聚合多级特征</li>
</ul>
<h2 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h2>
<h3 id="先前方法缺点"><a class="markdownIt-Anchor" href="#先前方法缺点"></a> 先前方法缺点</h3>
<p>参数量和计算成本太大，不利于模型在真实世界的部署实现</p>
<h3 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h3>
<ol>
<li>使用轻量的特征提取网络（MobileNetV2），同时为了弥补特征表示能力的不足，构建NAM来增强特征表示能力</li>
<li>设计一个具有轻量化模块的decoder，PCI、SAM</li>
</ol>
<h3 id="主要贡献"><a class="markdownIt-Anchor" href="#主要贡献"></a> 主要贡献</h3>
<ol>
<li>提出轻量化模型A2Net（3.78 M parameters and 6.02 G FLOPs），并且取得了sota</li>
<li>提出NAM增强backbone特征表示能力</li>
<li>提出PCI逐步找到不同特征级别的时间变化信息以准确识别变化对象，并且使用SAM来重新加权特征以实现渐进的特征聚合</li>
</ol>
<h2 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h2>
<h3 id="网络结构"><a class="markdownIt-Anchor" href="#网络结构"></a> 网络结构</h3>
<p>首先通过骨干网络提取多尺度特征，然后经过<strong>NAM</strong>对特征进行增强，最后获得差分特征。后面先将差分特征输入<strong>PCIM</strong>中进行差异特征增强然后经过<strong>SAM</strong>对特征进行重新加权，输出预测图。</p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20230224103752830.png" alt="image-20230224103752830" /></p>
<h3 id="nam"><a class="markdownIt-Anchor" href="#nam"></a> NAM</h3>
<p>由于backbone采用的是移动网络MobileNetV2，所以提取到的特征表征能力较弱，于是提出<strong>NAM</strong>对特征进行增强。具体操作为：所提取特征上下阶段特征分别进行最大池化和上采样后经过卷积与当前阶段特征进行<strong>concat</strong>，而后当前特征通过1×1卷积构成一个残差网络，保持当前阶段特征的主要信息。</p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20230224113134285.png" alt="image-20230224113134285" /></p>
<h3 id="pcim"><a class="markdownIt-Anchor" href="#pcim"></a> PCIM</h3>
<p>PCIM主要是为了成分挖掘差异特征中的变化信息，输入特征从大感受野到小感受野逐步挖掘变化信息。</p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20230224113608045.png" alt="image-20230224113608045" /></p>
<h3 id="sam"><a class="markdownIt-Anchor" href="#sam"></a> SAM</h3>
<p>在上一步通过<strong>PCIM</strong>已经充分挖掘了变化信息，但是由于高级特征缺少上下文信息的指导，容易造成噪声等无关信息。所以<strong>SAM</strong>旨在对特征进行重新加权，确保变化特征能够得到更多的关注，忽略无关特征。该模块首先经过1×1卷积然后通过激活层。最后得到变化图（值为0-1）和非变化图（用全1矩阵减去变化图），将两者进行<strong>concat</strong>，通过1×1卷积后作为权重map与原特征进行点乘，最后得到重加权的特征。</p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20230224114240434.png" alt="image-20230224114240434" /></p>
<h2 id="实验"><a class="markdownIt-Anchor" href="#实验"></a> 实验</h2>
<h3 id="对比实验"><a class="markdownIt-Anchor" href="#对比实验"></a> 对比实验</h3>
<p>该模型相比于其他的方法具有更好的效果。如图7第三行所示，相同的建筑物在不同的时间显示不同的颜色，从而导致一些与真实建筑物变化相反的无关变化，该方法能够较好地检测出变化区域；同时图8第六行，许多方法无法区分包含与建筑物外观相似的道路的伪变化。相反，所提出的方法可以很好地识别建筑物变化的边界和主体。</p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20230224114942640.png" alt="image-20230224114942640" /></p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20230224114957987.png" alt="image-20230224114957987" /></p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20230224115022493.png" alt="image-20230224115022493" /></p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20230224115046949.png" alt="image-20230224115046949" /></p>
<h3 id="消融实验"><a class="markdownIt-Anchor" href="#消融实验"></a> 消融实验</h3>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20230224115119249.png" alt="image-20230224115119249" /></p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<ol>
<li><strong>NAM</strong>对于特征有较好的增强效果，特征交互类似思路可行</li>
<li><strong>PCIM</strong>中利用不同感受野挖掘特征潜在信息也能够较好地运行，在对于较小分辨率特征是否可行？</li>
<li><strong>SAM</strong>类似于自注意力机制，主要是通过变化图和非变化图生成特征权重图。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://qingy735.github.io/posts/35686.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/title.ico">
      <meta itemprop="name" content="QingY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="QingY's Code Space">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | QingY's Code Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/35686.html" class="post-title-link" itemprop="url">《RACDNet：Resolution- and Alignment-Aware Change Detection Network for Optical Remote Sensing Imagery》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-11-25 11:52:16" itemprop="dateCreated datePublished" datetime="2022-11-25T11:52:16+08:00">2022-11-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-03 20:14:36" itemprop="dateModified" datetime="2024-04-03T20:14:36+08:00">2024-04-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BA%E6%96%87/" itemprop="url" rel="index"><span itemprop="name">论文</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>913</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>论文地址：<a target="_blank" rel="noopener" href="https://www.mdpi.com/2072-4292/14/18/4527">Remote Sensing | Free Full-Text | RACDNet: Resolution- and Alignment-Aware Change Detection Network for Optical Remote Sensing Imagery</a></p>
</blockquote>
<h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2>
<h3 id="动机"><a class="markdownIt-Anchor" href="#动机"></a> 动机</h3>
<p>变化检测任务是基于等效分辨率的共同配准多时相图像。由于传感器成像条件和重访周期的限制，很难获得所需的图像，特别是在紧急情况下。此外，准确的多时相图像配准在很大程度上受到大量对象变化和匹配算法的限制。</p>
<h3 id="主要思路"><a class="markdownIt-Anchor" href="#主要思路"></a> 主要思路</h3>
<ul>
<li>首先，提出了一种基于WDSR的轻量级超分辨率网络。为了更好地恢复高频细节信息，计算梯度权重并将其分配给不同的区域，从而迫使网络集中在难以重建的区域。</li>
<li>为了减轻过度平滑的影响，进一步引入了对抗损失和感知损失，以提高重建图像的视觉感知质量</li>
<li>在孪生U-Net中为了对齐双时态深度特征，可变形卷积单元 (DCU) 通过使用学习到的偏移量扭曲特征图来使用。</li>
<li>解码器中为了弥合编码器和解码器之间的语义鸿沟，嵌入了一个有效的注意单元（AU）。</li>
</ul>
<h3 id="主要工作"><a class="markdownIt-Anchor" href="#主要工作"></a> 主要工作</h3>
<ul>
<li>提出了一种新颖的超分辨率网络，它在恢复 RS 图像中的高频细节方面简单而有效。</li>
<li>提出了一种对齐感知 CD 网络，其中可以通过使用 DCU、ACU 和注意机制进一步引入双时态深度特征来显式对齐以提高 CD 性能</li>
</ul>
<h2 id="网络结构"><a class="markdownIt-Anchor" href="#网络结构"></a> 网络结构</h2>
<p>整体网络结构分为两部分，第一部分为将图像转为高分辨率图像来凸显高频部分，使得特征中高频细节信息更加丰富。第二部分为特征提取和变化信息生成部分，主要采用孪生U-Net网络结构进行特征提取，并且在双时相图像融合的过程中采用DCU模块进行图像特征配准，<strong>解决图像配准问题</strong></p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20221125120756581.png" alt="image-20221125120756581" /></p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20221125120956911.png" alt="image-20221125120956911" /></p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20221125121009521.png" alt="image-20221125121009521" /></p>
<h3 id="dcu"><a class="markdownIt-Anchor" href="#dcu"></a> DCU</h3>
<p>首先将双时相特征进行concat然后通过卷积层输出各个坐标的位移矩阵（即当前像素位置应当如何调整，分为x、y两个方向），之后将位移矩阵与对应特征相乘便得到了配准之后的特征，后续就可以做对应操作了。</p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20221125121232605.png" alt="image-20221125121232605" /></p>
<h3 id="au"><a class="markdownIt-Anchor" href="#au"></a> AU</h3>
<p>因为深层特征包含丰富的语义信息，能够很好地识别背景和前景，所以通过通道注意力得到深层特征的通道级别注意力来重新校准低级特征，不仅减轻了语义鸿沟而且还能很好地融合高级特征的语义特征和低级特征的细节信息。</p>
<p><img src="https://gitee.com/qingy735/blogimg/raw/master/img/image-20221125121726955.png" alt="image-20221125121726955" /></p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>图像高频信息在后续实验中可以着重思考，并且特征对齐、配准等也有实验价值。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">QingY</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">72k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:06</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.31/dist/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  



  <script src="/js/third-party/fancybox.js"></script>



  





</body>
</html>
